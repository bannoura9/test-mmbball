{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Fragment = require('./fragment');\n\nvar util = require('./util');\n\nvar ops = require('./ops');\n\nmodule.exports = /*#__PURE__*/function (_Fragment) {\n  _inherits(Cell, _Fragment);\n\n  var _super = _createSuper(Cell);\n\n  function Cell(doc, parent, opts) {\n    var _this;\n\n    _classCallCheck(this, Cell);\n\n    _this = _super.call(this, doc, parent);\n    _this._pending = [];\n    _this._firstPage = true;\n    _this._firstRendered = false;\n    _this._drawBorders = true; // create new cursor for cell context\n    // const previousCursor = this._cursor\n\n    _this._cursor = _this._cursor.clone();\n    applyOpts.call(_assertThisInitialized(_this), opts);\n    _this._previousStartX = _this._cursor.startX;\n\n    if (_this.x) {\n      _this._cursor.startX = _this.x;\n    } // adjust cursor according to cell padding\n\n\n    _this._cursor.startX += _this.paddingLeft;\n    _this._cursor.width -= _this.paddingLeft + _this.paddingRight;\n    _this._cursor.bottomOffset = _this.paddingBottom - _this.borderBottomWidth;\n    _this._startRendering = null;\n    return _this;\n  } /// private API\n\n\n  _createClass(Cell, [{\n    key: \"_pageBreak\",\n    value: function () {\n      var _pageBreak2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(level, insideBreak) {\n        var _this2 = this;\n\n        var renderHeight, actualHeight, contents, offset, idx, take;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                renderHeight = this._startY - this._cursor.bottom;\n                actualHeight = this._startY - this._cursor.y;\n\n                if (!(!insideBreak && this._firstPage && renderHeight / this._doc.height <= .15)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                // move already rendered cell content to the next page if the current cell height does only\n                // make up about 10% of the total page height\n                idx = this._doc._contents.indexOf(this._bgLayerRef);\n                take = this._endLayerRef ? this._doc._contents.indexOf(this._endLayerRef) - idx + 1 : this._doc._contents.length - idx;\n                contents = this._doc._contents.splice(idx, take);\n                offset = actualHeight - this.paddingTop + this.borderTopWidth;\n                _context2.next = 13;\n                break;\n\n              case 9:\n                // on page breaks, always draw background until the current bottom\n                this._cursor.y = this._cursor.bottom - this.paddingBottom; // create background on each page break\n\n                _context2.next = 12;\n                return this._createBackground(!this._firstRendered, false);\n\n              case 12:\n                this._firstRendered = true;\n\n              case 13:\n                this._firstPage = false;\n\n                if (!this._parent) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                _context2.next = 17;\n                return this._parent._pageBreak(level + 1, contents === undefined);\n\n              case 17:\n                // By pushing the following at the beginning of the cell's pending queue instead of executing\n                // it directly, we ensure that is executed just before the cell's content continues rendering\n                // on the next page - especially when cells are appended horizontally into rows.\n                this._pending.unshift( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          // reset some cursor values\n                          _this2._cursor.x = _this2._cursor.startX;\n                          _this2._cursor.cursorOffset = 0;\n\n                          if (!contents) {\n                            _context.next = 13;\n                            break;\n                          }\n\n                          _context.next = 5;\n                          return _this2._doc._startContentObject();\n\n                        case 5:\n                          _context.next = 7;\n                          return _this2._doc._write(ops.q() + ops.cm(1, 0, 0, 1, 0, _this2._cursor.y - _this2._startY));\n\n                        case 7:\n                          _this2._doc._contents.push.apply(_this2._doc._contents, contents);\n\n                          _context.next = 10;\n                          return _this2._doc._startContentObject();\n\n                        case 10:\n                          _context.next = 12;\n                          return _this2._doc._write(ops.Q());\n\n                        case 12:\n                          _this2._bgLayerRef = null;\n\n                        case 13:\n                          _this2._startY = _this2._cursor.y;\n\n                          if (offset > 0) {\n                            _this2._cursor.y -= offset;\n                          } // apply padding after page break (but only to most inner cell)\n\n\n                          if (level === 1) {\n                            _this2._cursor.y -= _this2.paddingTop - _this2.borderTopWidth;\n                            _this2._cursor.bottomOffset = _this2.paddingBottom - _this2.borderBottomWidth;\n                          } // TODO: is there a better way of achieving this?\n\n\n                          if (_this2._pending.length === 0) {\n                            _this2._cursor.y = _this2._startY;\n                          }\n\n                        case 17:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                })));\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _pageBreak(_x, _x2) {\n        return _pageBreak2.apply(this, arguments);\n      }\n\n      return _pageBreak;\n    }()\n  }, {\n    key: \"_createBackground\",\n    value: function () {\n      var _createBackground2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(hasTopBorder, hasBottomBorder) {\n        var hasBorder, layer, bgLayerIndex, height, bottom, chunk, borderColor, borderWidth, x, y1, y2, _x5, _y, _y2, x1, x2, y, _x6, _x7, _y3;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // if there is no backgroundColor, it is not necessary to create the background layer\n                hasBorder = this._drawBorders && (this.borderTopWidth > 0 || this.borderRightWidth > 0 || this.borderBottomWidth > 0 || this.borderLeftWidth > 0);\n\n                if (!(!this.backgroundColor && !hasBorder)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                _context3.next = 5;\n                return this._doc._startContentObject(null, true);\n\n              case 5:\n                // put the background layer behind the cell\n                layer = this._doc._contents.pop();\n                bgLayerIndex = this._bgLayerRef ? this._doc._contents.indexOf(this._bgLayerRef) : 0;\n\n                this._doc._contents.splice(bgLayerIndex, 0, layer); // calculate background height\n\n\n                height = this._startY - this._cursor.y;\n                bottom = this._cursor.bottom - this.paddingBottom + this.borderBottomWidth;\n\n                if (this._startY - height < bottom) {\n                  // if background height goes beyond bottom of document, trim it to the bottom\n                  height = this._startY - bottom;\n                }\n\n                chunk = ops.q(); // save graphics state\n\n                if (this.backgroundColor) {\n                  // write background\n                  chunk += ops.sc(this.backgroundColor[0], this.backgroundColor[1], this.backgroundColor[2]) // non-stroking color\n                  + ops.re(this._cursor.startX - this.paddingLeft, this._startY - height, this.outerWidth, height) // rectangle\n                  + ops.f(); // fill path\n                }\n\n                if (this._drawBorders) {\n                  borderColor = null;\n                  borderWidth = null; // draw left border\n\n                  if (this.borderLeftWidth > 0) {\n                    if (!borderColor || !util.rgbEqual(borderColor, this.borderLeftColor)) {\n                      chunk += ops.SC(this.borderLeftColor[0], this.borderLeftColor[1], this.borderLeftColor[2]); // stroking color\n\n                      borderColor = this.borderLeftColor;\n                    }\n\n                    if (borderWidth !== this.borderLeftWidth) {\n                      chunk += ops.w(this.borderLeftWidth); // line width\n\n                      borderWidth = this.borderLeftWidth;\n                    }\n\n                    x = this._cursor.startX - this.paddingLeft + this.borderLeftWidth / 2;\n                    y1 = this._startY;\n                    y2 = this._startY - height;\n                    chunk += ops.S(x, y1, 'm', x, y2, 'l'); // fill path\n                  } // draw right border\n\n\n                  if (this.borderRightWidth > 0) {\n                    if (!borderColor || !util.rgbEqual(borderColor, this.borderRightColor)) {\n                      chunk += ops.SC(this.borderRightColor[0], this.borderRightColor[1], this.borderRightColor[2]); // stroking color\n\n                      borderColor = this.borderRightColor;\n                    }\n\n                    if (borderWidth !== this.borderRightWidth) {\n                      chunk += ops.w(this.borderRightWidth); // line width\n\n                      borderWidth = this.borderRightWidth;\n                    }\n\n                    _x5 = this._cursor.startX - this.paddingLeft + this.outerWidth - this.borderRightWidth / 2;\n                    _y = this._startY;\n                    _y2 = this._startY - height;\n                    chunk += ops.S(_x5, _y, 'm', _x5, _y2, 'l'); // fill path\n                  } // draw top border\n\n\n                  if (hasTopBorder && this.borderTopWidth > 0) {\n                    if (!borderColor || !util.rgbEqual(borderColor, this.borderTopColor)) {\n                      chunk += ops.SC(this.borderTopColor[0], this.borderTopColor[1], this.borderTopColor[2]); // stroking color\n\n                      borderColor = this.borderTopColor;\n                    }\n\n                    if (borderWidth !== this.borderTopWidth) {\n                      chunk += ops.w(this.borderTopWidth); // line width\n\n                      borderWidth = this.borderTopWidth;\n                    }\n\n                    x1 = this._cursor.startX - this.paddingLeft;\n                    x2 = x1 + this.outerWidth;\n                    y = this._startY - this.borderTopWidth / 2;\n                    chunk += ops.S(x1, y, 'm', x2, y, 'l'); // fill path\n                  } // draw bottom border\n\n\n                  if (hasBottomBorder && this.borderBottomWidth > 0) {\n                    if (!borderColor || !util.rgbEqual(borderColor, this.borderBottomColor)) {\n                      chunk += ops.SC(this.borderBottomColor[0], this.borderBottomColor[1], this.borderBottomColor[2]); // stroking color\n\n                      borderColor = this.borderBottomColor;\n                    }\n\n                    if (borderWidth !== this.borderBottomWidth) {\n                      chunk += ops.w(this.borderBottomWidth); // line width\n\n                      borderWidth = this.borderBottomWidth;\n                    }\n\n                    _x6 = this._cursor.startX - this.paddingLeft;\n                    _x7 = _x6 + this.outerWidth;\n                    _y3 = this._startY - height + this.borderBottomWidth / 2;\n                    chunk += ops.S(_x6, _y3, 'm', _x7, _y3, 'l'); // fill path\n                  }\n                }\n\n                if (!(chunk.length > 0)) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                chunk += ops.Q(); // restore graphics state\n\n                _context3.next = 18;\n                return this._doc._write(chunk);\n\n              case 18:\n                // for succeeding pages put background layers at index 0 (for bgLayerRef === null, index 0\n                // will be used)\n                this._bgLayerRef = null; // update startAt to take page break into account\n\n                this._startY = this._cursor.startY;\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _createBackground(_x3, _x4) {\n        return _createBackground2.apply(this, arguments);\n      }\n\n      return _createBackground;\n    }()\n  }, {\n    key: \"_start\",\n    value: function () {\n      var _start2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this._doc._currentContent) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                _context4.next = 3;\n                return this._doc._startPage();\n\n              case 3:\n                if (!(this.minHeight > 0 && !this._parent._cursor.doesFit(this.minHeight))) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                _context4.next = 6;\n                return this._parent._pageBreak(1);\n\n              case 6:\n                if (this.y !== undefined) {\n                  this._cursor.y = this.y;\n                } // Note: We could call `doesFit(this.minHeight)` here again to test whether the cell fits on the\n                // newly created page. However, instead of throwing an error, when the minHeight is greater than\n                // the document height, the minHeight is bounded to the documents height.\n\n\n                this._startY = this._cursor.y;\n                this._cursor.x = this._cursor.startX;\n                this._cursor.y -= this.paddingTop;\n                this.outerWidth = this._cursor.width + this.paddingLeft + this.paddingRight; // start a new content layer for cells\n                // save the current layer ref, this will be used to place the background and border layer\n                // after the cell has been rendered\n                // Note: saving the index directly would  not work for nested rendering tasks\n\n                _context4.next = 13;\n                return this._doc._startContentObject(null, true);\n\n              case 13:\n                this._bgLayerRef = _context4.sent;\n\n                if (this._ended) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 17;\n                return new Promise(function (resolve) {\n                  _this3._startRendering = resolve;\n                });\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _start() {\n        return _start2.apply(this, arguments);\n      }\n\n      return _start;\n    }()\n  }, {\n    key: \"_end\",\n    value: function () {\n      var _end2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var height;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // apply bottom padding\n                this._cursor.y -= this.paddingBottom;\n                height = this._startY - this._cursor.y;\n\n                if (height < this.opts.minHeight) {\n                  this._cursor.y -= this.opts.minHeight - height;\n                } // create final createBackground\n\n\n                _context5.next = 5;\n                return this._createBackground(!this._firstRendered, true);\n\n              case 5:\n                // restore cursor\n                this._cursor.x = this._previousStartX;\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _end() {\n        return _end2.apply(this, arguments);\n      }\n\n      return _end;\n    }()\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this._startRendering) {\n        this._startRendering();\n      }\n\n      return Fragment.prototype.end.call(this);\n    }\n  }]);\n\n  return Cell;\n}(Fragment);\n\nfunction applyOpts(opts) {\n  this.opts = opts;\n\n  if ('width' in opts) {\n    this._cursor.width = opts.width;\n  }\n\n  if ('x' in opts) {\n    this.x = opts.x;\n  }\n\n  if ('y' in opts) {\n    this.y = opts.y;\n  }\n\n  this.paddingTop = opts.paddingTop || opts.padding || 0;\n  this.paddingRight = opts.paddingRight || opts.padding || 0;\n  this.paddingBottom = opts.paddingBottom || opts.padding || 0;\n  this.paddingLeft = opts.paddingLeft || opts.padding || 0; // background creation callback\n\n  this.backgroundColor = util.colorToRgb(opts.backgroundColor);\n  this.borderTopWidth = opts.borderTopWidth || opts.borderWidth || 0;\n  this.borderTopColor = util.colorToRgb(opts.borderTopColor || opts.borderColor || 0x000000);\n  this.borderRightWidth = opts.borderRightWidth || opts.borderWidth || 0;\n  this.borderRightColor = util.colorToRgb(opts.borderRightColor || opts.borderColor || 0x000000);\n  this.borderBottomWidth = opts.borderBottomWidth || opts.borderWidth || 0;\n  this.borderBottomColor = util.colorToRgb(opts.borderBottomColor || opts.borderColor || 0x000000);\n  this.borderLeftWidth = opts.borderLeftWidth || opts.borderWidth || 0;\n  this.borderLeftColor = util.colorToRgb(opts.borderLeftColor || opts.borderColor || 0x000000);\n  this.paddingTop += this.borderTopWidth;\n  this.paddingRight += this.borderRightWidth;\n  this.paddingBottom += this.borderBottomWidth;\n  this.paddingLeft += this.borderLeftWidth;\n  this.minHeight = opts.minHeight || 0;\n}","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/cell.js"],"names":["Fragment","require","util","ops","module","exports","doc","parent","opts","_pending","_firstPage","_firstRendered","_drawBorders","_cursor","clone","applyOpts","call","_previousStartX","startX","x","paddingLeft","width","paddingRight","bottomOffset","paddingBottom","borderBottomWidth","_startRendering","level","insideBreak","renderHeight","_startY","bottom","actualHeight","y","_doc","height","idx","_contents","indexOf","_bgLayerRef","take","_endLayerRef","length","contents","splice","offset","paddingTop","borderTopWidth","_createBackground","_parent","_pageBreak","undefined","unshift","cursorOffset","_startContentObject","_write","q","cm","push","apply","Q","hasTopBorder","hasBottomBorder","hasBorder","borderRightWidth","borderLeftWidth","backgroundColor","layer","pop","bgLayerIndex","chunk","sc","re","outerWidth","f","borderColor","borderWidth","rgbEqual","borderLeftColor","SC","w","y1","y2","S","borderRightColor","borderTopColor","x1","x2","borderBottomColor","startY","_currentContent","_startPage","minHeight","doesFit","_ended","Promise","resolve","prototype","end","padding","colorToRgb"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Fragment = require('./fragment')\nconst util = require('./util')\nconst ops = require('./ops')\n\nmodule.exports = class Cell extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent)\n\n    this._pending = []\n    this._firstPage = true\n    this._firstRendered = false\n    this._drawBorders = true\n\n    // create new cursor for cell context\n    // const previousCursor = this._cursor\n    this._cursor = this._cursor.clone()\n\n    applyOpts.call(this, opts)\n\n    this._previousStartX = this._cursor.startX\n    if (this.x) {\n      this._cursor.startX = this.x\n    }\n\n    // adjust cursor according to cell padding\n    this._cursor.startX += this.paddingLeft\n    this._cursor.width  -= this.paddingLeft + this.paddingRight\n    this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth\n\n    this._startRendering = null\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    const renderHeight = this._startY - this._cursor.bottom\n    const actualHeight = this._startY - this._cursor.y\n\n    let contents, offset\n    if (!insideBreak && this._firstPage && renderHeight / this._doc.height <= .15) {\n      // move already rendered cell content to the next page if the current cell height does only\n      // make up about 10% of the total page height\n      const idx = this._doc._contents.indexOf(this._bgLayerRef)\n      const take = this._endLayerRef ? (this._doc._contents.indexOf(this._endLayerRef) - idx + 1) : (this._doc._contents.length - idx)\n      contents = this._doc._contents.splice(idx, take)\n      offset = actualHeight - this.paddingTop + this.borderTopWidth\n    } else {\n      // on page breaks, always draw background until the current bottom\n      this._cursor.y = this._cursor.bottom - this.paddingBottom\n\n      // create background on each page break\n      await this._createBackground(!this._firstRendered, false)\n      this._firstRendered = true\n    }\n\n    this._firstPage = false\n\n    if (this._parent) {\n      await this._parent._pageBreak(level + 1, contents === undefined)\n    }\n\n    // By pushing the following at the beginning of the cell's pending queue instead of executing\n    // it directly, we ensure that is executed just before the cell's content continues rendering\n    // on the next page - especially when cells are appended horizontally into rows.\n    this._pending.unshift(async () => {\n      // reset some cursor values\n      this._cursor.x = this._cursor.startX\n      this._cursor.cursorOffset = 0\n\n      if (contents) {\n        await this._doc._startContentObject()\n        await this._doc._write(ops.q() + ops.cm(1, 0, 0, 1, 0, this._cursor.y - this._startY))\n        this._doc._contents.push.apply(this._doc._contents, contents)\n\n        await this._doc._startContentObject()\n        await this._doc._write(ops.Q())\n\n        this._bgLayerRef = null\n      }\n\n      this._startY = this._cursor.y\n\n      if (offset > 0) {\n        this._cursor.y -= offset\n      }\n\n      // apply padding after page break (but only to most inner cell)\n      if (level === 1) {\n        this._cursor.y -= this.paddingTop - this.borderTopWidth\n        this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth\n      }\n\n      // TODO: is there a better way of achieving this?\n      if (this._pending.length === 0) {\n        this._cursor.y = this._startY\n      }\n    })\n  }\n\n  async _createBackground(hasTopBorder, hasBottomBorder) {\n    // if there is no backgroundColor, it is not necessary to create the background layer\n    const hasBorder = this._drawBorders && (this.borderTopWidth > 0 || this.borderRightWidth > 0 || this.borderBottomWidth > 0 || this.borderLeftWidth > 0)\n    if (!this.backgroundColor && !hasBorder) {\n      return\n    }\n\n    // start a new content object for the background and border layer\n    await this._doc._startContentObject(null, true)\n\n    // put the background layer behind the cell\n    const layer = this._doc._contents.pop()\n    const bgLayerIndex = this._bgLayerRef ? this._doc._contents.indexOf(this._bgLayerRef) : 0\n    this._doc._contents.splice(bgLayerIndex, 0, layer)\n\n    // calculate background height\n    let height = this._startY - this._cursor.y\n    const bottom = this._cursor.bottom - this.paddingBottom + this.borderBottomWidth\n    if (this._startY - height < bottom) {\n      // if background height goes beyond bottom of document, trim it to the bottom\n      height = this._startY - bottom\n    }\n\n    let chunk = ops.q() // save graphics state\n\n    if (this.backgroundColor) {\n      // write background\n      chunk += ops.sc(this.backgroundColor[0], this.backgroundColor[1], this.backgroundColor[2]) // non-stroking color\n             + ops.re(this._cursor.startX - this.paddingLeft, this._startY - height, this.outerWidth, height) // rectangle\n             + ops.f() // fill path\n    }\n\n    if (this._drawBorders) {\n      let borderColor = null\n      let borderWidth = null\n\n      // draw left border\n      if (this.borderLeftWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderLeftColor)) {\n          chunk += ops.SC(this.borderLeftColor[0], this.borderLeftColor[1], this.borderLeftColor[2]) // stroking color\n          borderColor = this.borderLeftColor\n        }\n\n        if (borderWidth !== this.borderLeftWidth) {\n          chunk += ops.w(this.borderLeftWidth) // line width\n          borderWidth = this.borderLeftWidth\n        }\n\n        const x = this._cursor.startX - this.paddingLeft + this.borderLeftWidth / 2\n        const y1 = this._startY\n        const y2 = this._startY - height\n\n        chunk += ops.S(x, y1, 'm', x, y2, 'l') // fill path\n      }\n\n      // draw right border\n      if (this.borderRightWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderRightColor)) {\n          chunk += ops.SC(this.borderRightColor[0], this.borderRightColor[1], this.borderRightColor[2]) // stroking color\n          borderColor = this.borderRightColor\n        }\n\n        if (borderWidth !== this.borderRightWidth) {\n          chunk += ops.w(this.borderRightWidth) // line width\n          borderWidth = this.borderRightWidth\n        }\n\n        const x = this._cursor.startX - this.paddingLeft + this.outerWidth - this.borderRightWidth / 2\n        const y1 = this._startY\n        const y2 = this._startY - height\n\n        chunk += ops.S(x, y1, 'm', x, y2, 'l') // fill path\n      }\n\n      // draw top border\n      if (hasTopBorder && this.borderTopWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderTopColor)) {\n          chunk += ops.SC(this.borderTopColor[0], this.borderTopColor[1], this.borderTopColor[2]) // stroking color\n          borderColor = this.borderTopColor\n        }\n\n        if (borderWidth !== this.borderTopWidth) {\n          chunk += ops.w(this.borderTopWidth) // line width\n          borderWidth = this.borderTopWidth\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft\n        const x2 = x1 + this.outerWidth\n        const y = this._startY - this.borderTopWidth / 2\n\n        chunk += ops.S(x1, y, 'm', x2, y, 'l') // fill path\n      }\n\n      // draw bottom border\n      if (hasBottomBorder && this.borderBottomWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderBottomColor)) {\n          chunk += ops.SC(this.borderBottomColor[0], this.borderBottomColor[1], this.borderBottomColor[2]) // stroking color\n          borderColor = this.borderBottomColor\n        }\n\n        if (borderWidth !== this.borderBottomWidth) {\n          chunk += ops.w(this.borderBottomWidth) // line width\n          borderWidth = this.borderBottomWidth\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft\n        const x2 = x1 + this.outerWidth\n        const y = this._startY - height + this.borderBottomWidth / 2\n\n        chunk += ops.S(x1, y, 'm', x2, y, 'l') // fill path\n      }\n    }\n\n    if (chunk.length > 0) {\n      chunk += ops.Q() // restore graphics state\n      await this._doc._write(chunk)\n    }\n\n    // for succeeding pages put background layers at index 0 (for bgLayerRef === null, index 0\n    // will be used)\n    this._bgLayerRef = null\n\n    // update startAt to take page break into account\n    this._startY = this._cursor.startY\n  }\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage()\n    }\n\n    if (this.minHeight > 0 && !this._parent._cursor.doesFit(this.minHeight)) {\n      await this._parent._pageBreak(1)\n    }\n\n    if (this.y !== undefined) {\n      this._cursor.y = this.y\n    }\n\n    // Note: We could call `doesFit(this.minHeight)` here again to test whether the cell fits on the\n    // newly created page. However, instead of throwing an error, when the minHeight is greater than\n    // the document height, the minHeight is bounded to the documents height.\n\n    this._startY = this._cursor.y\n\n    this._cursor.x = this._cursor.startX\n    this._cursor.y -= this.paddingTop\n\n    this.outerWidth = this._cursor.width + this.paddingLeft + this.paddingRight\n\n    // start a new content layer for cells\n    // save the current layer ref, this will be used to place the background and border layer\n    // after the cell has been rendered\n    // Note: saving the index directly would  not work for nested rendering tasks\n    this._bgLayerRef = await this._doc._startContentObject(null, true)\n\n    // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n    if (!this._ended) {\n      await new Promise(resolve => {this._startRendering = resolve})\n    }\n  }\n\n  async _end() {\n    // apply bottom padding\n    this._cursor.y -= this.paddingBottom\n\n    const height = this._startY - this._cursor.y\n    if (height < this.opts.minHeight) {\n      this._cursor.y -= this.opts.minHeight - height\n    }\n\n    // create final createBackground\n    await this._createBackground(!this._firstRendered, true)\n\n    // restore cursor\n    this._cursor.x = this._previousStartX\n  }\n\n  end() {\n    if (this._startRendering) {\n      this._startRendering()\n    }\n    return Fragment.prototype.end.call(this)\n  }\n}\n\nfunction applyOpts(opts) {\n  this.opts = opts\n\n  if ('width' in opts) {\n    this._cursor.width = opts.width\n  }\n\n  if ('x' in opts) {\n    this.x = opts.x\n  }\n\n  if ('y' in opts) {\n    this.y = opts.y\n  }\n\n  this.paddingTop    = opts.paddingTop    || opts.padding || 0\n  this.paddingRight  = opts.paddingRight  || opts.padding || 0\n  this.paddingBottom = opts.paddingBottom || opts.padding || 0\n  this.paddingLeft   = opts.paddingLeft   || opts.padding || 0\n\n  // background creation callback\n  this.backgroundColor = util.colorToRgb(opts.backgroundColor)\n\n  this.borderTopWidth = opts.borderTopWidth || opts.borderWidth || 0\n  this.borderTopColor = util.colorToRgb(opts.borderTopColor || opts.borderColor || 0x000000)\n\n  this.borderRightWidth = opts.borderRightWidth || opts.borderWidth || 0\n  this.borderRightColor = util.colorToRgb(opts.borderRightColor || opts.borderColor || 0x000000)\n\n  this.borderBottomWidth = opts.borderBottomWidth || opts.borderWidth || 0\n  this.borderBottomColor = util.colorToRgb(opts.borderBottomColor || opts.borderColor || 0x000000)\n\n  this.borderLeftWidth = opts.borderLeftWidth || opts.borderWidth || 0\n  this.borderLeftColor = util.colorToRgb(opts.borderLeftColor || opts.borderColor || 0x000000)\n\n  this.paddingTop    += this.borderTopWidth\n  this.paddingRight  += this.borderRightWidth\n  this.paddingBottom += this.borderBottomWidth\n  this.paddingLeft   += this.borderLeftWidth\n\n  this.minHeight = opts.minHeight || 0\n}"]},"metadata":{},"sourceType":"script"}