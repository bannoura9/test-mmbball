{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PDFObject = require('./object');\n\nvar util = require('../util');\n\nmodule.exports = /*#__PURE__*/function () {\n  function PDFXref() {\n    _classCallCheck(this, PDFXref);\n\n    this.objects = [];\n    this.trailer = null;\n  }\n\n  _createClass(PDFXref, [{\n    key: \"add\",\n    value: function add(id, data) {\n      this.objects[id] = data;\n    }\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      return this.objects[id] && this.objects[id].obj;\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(id) {\n      return this.objects[id] && this.objects[id].offset || null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var xref = 'xref\\n';\n      var range = {\n        from: 0,\n        refs: [0]\n      };\n      var ranges = [range];\n\n      for (var i = 1; i < this.objects.length; ++i) {\n        var obj = this.objects[i];\n\n        if (!obj) {\n          if (range) {\n            range = null;\n          }\n\n          continue;\n        }\n\n        if (!range) {\n          range = {\n            from: i,\n            refs: []\n          };\n          ranges.push(range);\n        }\n\n        range.refs.push(obj.offset);\n      }\n\n      ranges.forEach(function (range) {\n        xref += range.from + ' ' + range.refs.length + '\\n';\n        range.refs.forEach(function (ref, i) {\n          if (range.from === 0 && i === 0) {\n            xref += '0000000000 65535 f \\n';\n          } else {\n            xref += '0000000000'.substr(ref.toString().length) + ref + ' 00000 n \\n';\n          }\n        });\n      });\n      return xref;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(_, lexer, trial) {\n      var xref = new PDFXref();\n\n      if (lexer.getString(4) !== 'xref') {\n        return this.parseXrefObject(_, lexer, trial);\n      }\n\n      lexer.readString(4); // skip xref\n\n      lexer.skipSpace(null, trial);\n      lexer.skipEOL(1, trial);\n      var start;\n\n      while ((start = lexer.readNumber(true)) !== undefined) {\n        lexer.skipSpace(1);\n        var count = lexer.readNumber();\n        lexer.skipSpace(null, true);\n        lexer.skipEOL(1);\n\n        for (var i = 0, len = 0 + count; i < len; ++i) {\n          var offset = lexer.readNumber();\n          lexer.skipSpace(1);\n          lexer.readNumber(); // generation\n\n          lexer.skipSpace(1);\n          var key = lexer.readString(1);\n          lexer.skipSpace(null, true);\n          lexer.skipEOL(1);\n          var id = start + i;\n\n          if (id > 0 && key === 'n') {\n            xref.add(id, {\n              offset: offset\n            });\n          }\n        }\n      }\n\n      return xref;\n    } // TODO: this implementation needs to be improved\n\n  }, {\n    key: \"parseXrefObject\",\n    value: function parseXrefObject(_, lexer, trial) {\n      var xref = new PDFXref();\n      var obj;\n\n      try {\n        obj = PDFObject.parse(xref, lexer, trial);\n      } catch (_) {\n        throw new Error('Invalid xref: xref expected but not found');\n      }\n\n      var kind = obj.properties.get(\"Type\");\n\n      if (!kind || kind.name !== \"XRef\") {\n        throw new Error(\"Invalid xref object at \" + lexer.pos);\n      }\n\n      var stream = util.inflate(obj);\n      xref.trailer = obj.properties;\n      var index = obj.properties.get(\"Index\");\n      var start = index ? index[0] : 0;\n      var w = obj.properties.get(\"W\");\n      var typeSize = w[0] || 1;\n      var offsetSize = w[1] || 2;\n      var genSize = w[2] || 1;\n      var len = stream.length / (typeSize + offsetSize + genSize);\n      var pos = 0;\n\n      for (var i = 0; i < len; ++i) {\n        var type = readUint(stream, pos, typeSize);\n        pos += typeSize;\n        var offset = readUint(stream, pos, offsetSize);\n        pos += offsetSize;\n\n        switch (type) {\n          case 0:\n            // free\n            pos += genSize;\n            continue;\n          // skip type 0 entries (free entries)\n\n          case 1:\n            // normal\n            xref.add(start + i, {\n              offset: offset\n            });\n            pos += genSize;\n            break;\n\n          case 2:\n            // compressed\n            xref.add(start + i, {\n              compressed: true,\n              id: offset,\n              ix: readUint(stream, pos, genSize)\n            });\n            pos += genSize;\n            break;\n\n          default:\n            continue;\n        }\n      }\n\n      return xref;\n    }\n  }]);\n\n  return PDFXref;\n}();\n\nfunction readUint(src, pos, size) {\n  var val = 0;\n\n  for (var i = 0; i < size; ++i) {\n    // for (let i = size - 1; i > 0; --i) {\n    val += src[pos + size - i - 1] << 8 * i;\n  }\n\n  return val;\n}","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/object/xref.js"],"names":["PDFObject","require","util","module","exports","objects","trailer","id","data","obj","offset","xref","range","from","refs","ranges","i","length","push","forEach","ref","substr","toString","_","lexer","trial","PDFXref","getString","parseXrefObject","readString","skipSpace","skipEOL","start","readNumber","undefined","count","len","key","add","parse","Error","kind","properties","get","name","pos","stream","inflate","index","w","typeSize","offsetSize","genSize","type","readUint","compressed","ix","src","size","val"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PDFObject = require('./object')\nconst util = require('../util')\n\nmodule.exports = class PDFXref {\n  constructor() {\n    this.objects = []\n    this.trailer = null\n  }\n\n  add(id, data) {\n    this.objects[id] = data\n  }\n\n  get(id) {\n    return this.objects[id] && this.objects[id].obj\n  }\n\n  getOffset(id) {\n    return this.objects[id] && this.objects[id].offset || null\n  }\n\n  toString() {\n    let xref = 'xref\\n'\n\n    let range  = { from: 0, refs: [0] }\n    const ranges = [range]\n\n    for (let i = 1; i < this.objects.length; ++i) {\n      const obj = this.objects[i]\n      if (!obj) {\n        if (range) {\n          range = null\n        }\n        continue\n      }\n\n      if (!range) {\n        range = { from: i, refs: [] }\n        ranges.push(range)\n      }\n\n      range.refs.push(obj.offset)\n    }\n\n    ranges.forEach(function(range) {\n      xref += range.from + ' ' + range.refs.length + '\\n'\n\n      range.refs.forEach(function(ref, i) {\n        if (range.from === 0 && i === 0) {\n          xref += '0000000000 65535 f \\n'\n        } else {\n          xref += '0000000000'.substr(ref.toString().length) + ref + ' 00000 n \\n'\n        }\n      })\n    })\n\n    return xref\n  }\n\n  static parse(_, lexer, trial) {\n    const xref = new PDFXref()\n\n    if (lexer.getString(4) !== 'xref') {\n      return this.parseXrefObject(_, lexer, trial)\n    }\n\n    lexer.readString(4) // skip xref\n    lexer.skipSpace(null, trial)\n    lexer.skipEOL(1, trial)\n\n    let start\n    while ((start = lexer.readNumber(true)) !== undefined) {\n      lexer.skipSpace(1)\n      const count = lexer.readNumber()\n      lexer.skipSpace(null, true)\n      lexer.skipEOL(1)\n\n      for (let i = 0, len = 0 + count; i < len; ++i) {\n        const offset = lexer.readNumber()\n        lexer.skipSpace(1)\n        lexer.readNumber() // generation\n        lexer.skipSpace(1)\n        const key = lexer.readString(1)\n        lexer.skipSpace(null, true)\n        lexer.skipEOL(1)\n\n        const id = start + i\n        if (id > 0 && key === 'n') {\n          xref.add(id, {\n            offset: offset,\n          })\n        }\n      }\n    }\n\n    return xref\n  }\n\n  // TODO: this implementation needs to be improved\n  static parseXrefObject(_, lexer, trial) {\n    const xref = new PDFXref()\n\n    let obj\n\n    try {\n      obj = PDFObject.parse(xref, lexer, trial)\n    } catch (_) {\n      throw new Error('Invalid xref: xref expected but not found')\n    }\n\n    let kind = obj.properties.get(\"Type\")\n    if (!kind || kind.name !== \"XRef\") {\n      throw new Error(\"Invalid xref object at \" + lexer.pos)\n    }\n\n    const stream = util.inflate(obj)\n\n    xref.trailer = obj.properties\n\n    const index = obj.properties.get(\"Index\")\n    const start = index ? index[0] : 0\n    const w = obj.properties.get(\"W\")\n    const typeSize = w[0] || 1\n    const offsetSize = w[1] || 2\n    const genSize = w[2] || 1\n    const len = stream.length / (typeSize + offsetSize + genSize)\n    let pos = 0\n    for (let i = 0; i < len; ++i) {\n      const type = readUint(stream, pos, typeSize)\n      pos += typeSize\n      const offset = readUint(stream, pos, offsetSize)\n      pos += offsetSize\n      switch (type) {\n      case 0: // free\n        pos += genSize\n        continue // skip type 0 entries (free entries)\n      case 1: // normal\n        xref.add(start + i, {\n          offset\n        })\n        pos += genSize\n        break\n      case 2: // compressed\n        xref.add(start + i, {\n          compressed: true,\n          id:         offset,\n          ix:         readUint(stream, pos, genSize),\n        })\n        pos += genSize\n        break\n      default:\n        continue\n      }\n    }\n\n    return xref\n  }\n}\n\nfunction readUint(src, pos, size) {\n  let val = 0\n  for (let i = 0; i < size; ++i) {\n  // for (let i = size - 1; i > 0; --i) {\n    val += src[pos + size - i - 1] << (8 * i)\n  }\n  return val\n}\n"]},"metadata":{},"sourceType":"script"}