{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Lexer = require('./lexer');\n\nvar PDF = require('../object');\n\nvar util = require('../util');\n\nvar Parser = /*#__PURE__*/function () {\n  // ab ... ArrayBuffer\n  function Parser(ab) {\n    _classCallCheck(this, Parser);\n\n    this.src = new Uint8Array(util.toArrayBuffer(ab));\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse() {\n      var index = lastIndexOf(this.src, 'startxref', 128);\n\n      if (index === -1) {\n        throw new Error('Invalid PDF: startxref not found');\n      }\n\n      index += 'startxref'.length; // skip whitespaces\n\n      while (Lexer.isWhiteSpace(this.src[++index])) {}\n\n      var str = '';\n\n      while (this.src[index] >= 0x30 && this.src[index] <= 0x39) {\n        // between 0 and 9\n        str += String.fromCharCode(this.src[index++]);\n      }\n\n      var startXRef = parseInt(str, 10);\n\n      if (isNaN(startXRef)) {\n        throw new Error('Invalid PDF: startxref is not a number');\n      }\n\n      var lexer = new Lexer(this.src);\n      lexer.shift(startXRef);\n      this.xref = PDF.Xref.parse(null, lexer);\n      this.trailer = this.xref.trailer || PDF.Trailer.parse(this.xref, lexer);\n      var trailer = this.trailer;\n\n      while (trailer.has('Prev')) {\n        var prevTrailerPos = trailer.get('Prev'); // Ignore prev pointers to the document beginning. This is not according to the PDF spec, but\n        // there are PDFs out there doing it anyway.\n\n        if (prevTrailerPos === 0) {\n          break;\n        }\n\n        lexer.pos = trailer.get('Prev');\n        var xref = PDF.Xref.parse(null, lexer);\n\n        for (var i = 0; i < xref.objects.length; ++i) {\n          var obj = xref.objects[i];\n\n          if (obj && !this.xref.objects[i]) {\n            this.xref.objects[i] = obj;\n          }\n        }\n\n        trailer = xref.trailer || PDF.Trailer.parse(xref, lexer);\n      }\n    }\n  }], [{\n    key: \"addObjectsRecursive\",\n    value: function addObjectsRecursive(objects, value) {\n      switch (true) {\n        case value instanceof PDF.Reference:\n          if (objects.indexOf(value.object) > -1) {\n            break;\n          }\n\n          objects.push(value.object);\n          Parser.addObjectsRecursive(objects, value.object);\n          break;\n\n        case value instanceof PDF.Object:\n          Parser.addObjectsRecursive(objects, value.properties);\n          Parser.addObjectsRecursive(objects, value.content);\n          break;\n\n        case value instanceof PDF.Dictionary:\n          for (var key in value.dictionary) {\n            if (key === '/Parent') {\n              // ignore parent property to prevent moving above Page objects\n              continue;\n            }\n\n            Parser.addObjectsRecursive(objects, value.dictionary[key]);\n          }\n\n          break;\n\n        case Array.isArray(value):\n          value.forEach(function (item) {\n            Parser.addObjectsRecursive(objects, item);\n          });\n          break;\n      }\n    }\n  }]);\n\n  return Parser;\n}();\n\nmodule.exports = Parser;\n\nfunction lastIndexOf(src, key, step) {\n  if (!step) step = 1024;\n  var pos = src.length,\n      index = -1;\n\n  while (index === -1 && pos > 0) {\n    pos -= step - key.length;\n    index = find(src, key, Math.max(pos, 0), step, true);\n  }\n\n  return index;\n}\n\nfunction find(src, key, pos, limit, backwards) {\n  if (pos + limit > src.length) {\n    limit = src.length - pos;\n  }\n\n  var str = String.fromCharCode.apply(null, src.subarray(pos, pos + limit));\n  var index = backwards ? str.lastIndexOf(key) : str.indexOf(key);\n\n  if (index > -1) {\n    index += pos;\n  }\n\n  return index;\n}","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/parser/parser.js"],"names":["Lexer","require","PDF","util","Parser","ab","src","Uint8Array","toArrayBuffer","index","lastIndexOf","Error","length","isWhiteSpace","str","String","fromCharCode","startXRef","parseInt","isNaN","lexer","shift","xref","Xref","parse","trailer","Trailer","has","prevTrailerPos","get","pos","i","objects","obj","value","Reference","indexOf","object","push","addObjectsRecursive","Object","properties","content","Dictionary","key","dictionary","Array","isArray","forEach","item","module","exports","step","find","Math","max","limit","backwards","apply","subarray"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Lexer = require('./lexer')\nconst PDF = require('../object')\nconst util = require('../util')\n\nclass Parser {\n  // ab ... ArrayBuffer\n  constructor(ab) {\n    this.src = new Uint8Array(util.toArrayBuffer(ab))\n  }\n\n  parse() {\n    let index = lastIndexOf(this.src, 'startxref', 128)\n    if (index === -1) {\n      throw new Error('Invalid PDF: startxref not found')\n    }\n\n    index += 'startxref'.length\n\n    // skip whitespaces\n    while (Lexer.isWhiteSpace(this.src[++index])) {\n    }\n\n    let str = ''\n    while (this.src[index] >= 0x30 && this.src[index] <= 0x39) { // between 0 and 9\n      str +=  String.fromCharCode(this.src[index++])\n    }\n\n    const startXRef = parseInt(str, 10)\n\n    if (isNaN(startXRef)) {\n      throw new Error('Invalid PDF: startxref is not a number')\n    }\n\n    const lexer = new Lexer(this.src)\n    lexer.shift(startXRef)\n\n    this.xref    = PDF.Xref.parse(null, lexer)\n    this.trailer = this.xref.trailer || PDF.Trailer.parse(this.xref, lexer)\n\n    let trailer = this.trailer\n    while (trailer.has('Prev')) {\n      const prevTrailerPos = trailer.get('Prev');\n      // Ignore prev pointers to the document beginning. This is not according to the PDF spec, but\n      // there are PDFs out there doing it anyway.\n      if (prevTrailerPos === 0) {\n        break;\n      }\n\n      lexer.pos = trailer.get('Prev')\n      const xref = PDF.Xref.parse(null, lexer)\n\n      for (let i = 0; i < xref.objects.length; ++i) {\n        const obj = xref.objects[i]\n        if (obj && !this.xref.objects[i]) {\n          this.xref.objects[i] = obj\n        }\n      }\n\n      trailer = xref.trailer || PDF.Trailer.parse(xref, lexer)\n    }\n  }\n\n  static addObjectsRecursive(objects, value) {\n    switch (true) {\n      case value instanceof PDF.Reference:\n        if (objects.indexOf(value.object) > -1) {\n          break\n        }\n        objects.push(value.object)\n        Parser.addObjectsRecursive(objects, value.object)\n        break\n      case value instanceof PDF.Object:\n        Parser.addObjectsRecursive(objects, value.properties)\n        Parser.addObjectsRecursive(objects, value.content)\n        break\n      case value instanceof PDF.Dictionary:\n        for (const key in value.dictionary) {\n          if (key === '/Parent') {\n            // ignore parent property to prevent moving above Page objects\n            continue\n          }\n          Parser.addObjectsRecursive(objects, value.dictionary[key])\n        }\n        break\n      case Array.isArray(value):\n        value.forEach(function(item) {\n          Parser.addObjectsRecursive(objects, item)\n        })\n        break\n    }\n  }\n}\n\nmodule.exports = Parser\n\nfunction lastIndexOf(src, key, step) {\n  if (!step) step = 1024\n  let pos = src.length, index = -1\n\n  while (index === -1 && pos > 0) {\n    pos -= step - key.length\n    index = find(src, key, Math.max(pos, 0), step, true)\n  }\n\n  return index\n}\n\nfunction find(src, key, pos, limit, backwards) {\n  if (pos + limit > src.length) {\n    limit = src.length - pos\n  }\n\n  const str = String.fromCharCode.apply(null, src.subarray(pos, pos + limit))\n  let index = backwards ? str.lastIndexOf(key) : str.indexOf(key)\n  if (index > -1) {\n    index += pos\n  }\n  return index\n}\n"]},"metadata":{},"sourceType":"script"}