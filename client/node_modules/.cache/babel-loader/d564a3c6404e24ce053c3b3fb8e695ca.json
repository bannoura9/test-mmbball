{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _construct = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/construct\");\n\nvar _createForOfIteratorHelper = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Fragment = require('./fragment');\n\nvar LineBreaker = require('@rkusa/linebreak');\n\nvar unorm = require('unorm');\n\nvar ops = require('./ops');\n\nvar util = require('./util');\n\nvar Font = require('./font/base');\n\nvar PDF = require('./object');\n\nvar UNDERLINE_FLAG = 1;\nvar STRIKETHROUGH_FLAG = 2;\n\nvar Text = module.exports = /*#__PURE__*/function (_Fragment) {\n  _inherits(Text, _Fragment);\n\n  var _super = _createSuper(Text);\n\n  function Text(doc, parent, opts) {\n    var _this;\n\n    _classCallCheck(this, Text);\n\n    _this = _super.call(this, doc, parent);\n    _this._line = [];\n    _this._spaceLeft = 0;\n    _this._parts = 0;\n    _this._isFirstLine = true;\n    _this._isNewLine = true;\n    _this._previousFont = null;\n    _this._previousFontSize = null;\n    _this._previousColor = null;\n    _this._previousHeight = 0;\n    _this._previousDescent = 0;\n    _this.opts = opts;\n    _this.defaultFont = opts.font || _this._doc.defaultFont;\n    _this.defaultFontSize = opts.fontSize || _this._doc.defaultFontSize;\n    _this.defaultColor = opts.color && util.colorToRgb(opts.color) || _this._doc.defaultColor;\n    _this.defaultLineHeight = opts.lineHeight || _this._doc.defaultLineHeight;\n    _this.defaultDecoration = (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0);\n    _this.alignment = opts.alignment || opts.textAlign || 'left';\n    _this.link = opts.link;\n    _this.destination = opts.destination;\n    _this.goTo = opts.goTo;\n    return _this;\n  } /// private API\n\n\n  _createClass(Text, [{\n    key: \"_start\",\n    value: function () {\n      var _start2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this._doc._currentContent) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return this._doc._startPage();\n\n              case 3:\n                this._spaceLeft = this._cursor.width;\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _start() {\n        return _start2.apply(this, arguments);\n      }\n\n      return _start;\n    }()\n  }, {\n    key: \"_end\",\n    value: function () {\n      var _end2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._doc._write(ops.ET());\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _end() {\n        return _end2.apply(this, arguments);\n      }\n\n      return _end;\n    }()\n  }, {\n    key: \"_render\",\n    value: function () {\n      var _render2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(text, opts) {\n        var _this2 = this;\n\n        var font, fontSize, color, lineHeight, link, destination, goTo, decoration, breaker, last, bk, isLastTextChunk, postponeLinebreak, nextWord, word, until, lastIsSpace, wordWidth, offsetWidth, spaceWidth, isLastWord, notEnoughSpace, i, w, subword, left, height, descent, _iterator, _step, _w2, h, d, _ret, freeSpace, spacing, isLastLine, chunk, lh, out, rangeStyleArgs, underlineStyle, strikethroughStyle, linkStyle, destinationStyle, goToStyle, lastIx, _i, _w, fontStyleChanged, colorChanged, alias, kerning, pos, _i2, _subword;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._parts--;\n\n                if (Font.isFont(opts.font || this.defaultFont)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new TypeError('invalid font: ' + font);\n\n              case 3:\n                font = this._doc._fontInstance(opts.font || this.defaultFont);\n                fontSize = opts.fontSize || this.defaultFontSize;\n                color = opts.color && util.colorToRgb(opts.color) || this.defaultColor;\n                lineHeight = opts.lineHeight || this.defaultLineHeight;\n                link = opts.link || this.link;\n                destination = opts.destination || this.destination;\n                goTo = opts.goTo || this.goTo;\n                decoration = this.defaultDecoration | (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0); // enforce string\n\n                text = String(text);\n                text = text.replace(/\\r\\n/g, '\\n').replace(/\\u2028|\\u2029/g, ''); // <- TODO: does this break things?\n\n                breaker = new LineBreaker(text);\n                last = 0;\n                isLastTextChunk = this._parts === 0 && this._ended;\n                postponeLinebreak = false;\n                nextWord = null;\n\n              case 18:\n                if (!(nextWord !== null || postponeLinebreak || (bk = breaker.nextBreak()) || isLastTextChunk && this._line.length > 0)) {\n                  _context4.next = 112;\n                  break;\n                }\n\n                word = null;\n\n                if (!nextWord) {\n                  _context4.next = 25;\n                  break;\n                }\n\n                word = nextWord;\n                nextWord = null;\n                _context4.next = 36;\n                break;\n\n              case 25:\n                if (!bk) {\n                  _context4.next = 36;\n                  break;\n                }\n\n                until = bk.position;\n                lastIsSpace = text[bk.position - 1].match(/\\s/);\n\n                if (lastIsSpace) {\n                  until--;\n                } // get the string between the last break and this one\n\n\n                word = text.slice(last, until); // separate words, if has whitespace, is at the end of the text or\n                // ends with a whitespace\n\n                if (!(bk.position === text.length || lastIsSpace)) {\n                  _context4.next = 34;\n                  break;\n                }\n\n                last = bk.position;\n                _context4.next = 35;\n                break;\n\n              case 34:\n                return _context4.abrupt(\"continue\", 18);\n\n              case 35:\n                word = unorm.nfc(word);\n\n              case 36:\n                wordWidth = 0;\n                offsetWidth = 0;\n                spaceWidth = 0;\n\n                if (word) {\n                  wordWidth = font.stringWidth(word, fontSize);\n                  offsetWidth = wordWidth.width;\n                  spaceWidth = font.stringWidth(' ', fontSize).width; // add whitespace length for every word, except the first on in the line\n                  // on the first line, during the first word the line array is empty, however, for succeeding\n                  // lines the line array already contains the word that did not fit into the previous line\n\n                  if (this._line.length > (this._isNewLine ? 0 : 1)) {\n                    offsetWidth += spaceWidth;\n                  }\n                } // render line if there is a line break, if we hit the last word of the text, if we\n                // have manual page breaks, or if there is not enough space on the line left\n\n\n                isLastWord = (!bk || bk.position === text.length) && isLastTextChunk;\n                notEnoughSpace = this._spaceLeft < offsetWidth;\n\n                if (!(postponeLinebreak || bk && bk.required || isLastWord || notEnoughSpace)) {\n                  _context4.next = 108;\n                  break;\n                }\n\n                if (!(this._line.length === 0 && notEnoughSpace)) {\n                  _context4.next = 58;\n                  break;\n                }\n\n                i = word.length - 1;\n\n              case 45:\n                if (!(i >= 0)) {\n                  _context4.next = 58;\n                  break;\n                }\n\n                w = font.stringWidth(word.slice(i), fontSize);\n\n                if (!(this._spaceLeft >= offsetWidth - w.width)) {\n                  _context4.next = 55;\n                  break;\n                }\n\n                subword = word.slice(0, i);\n\n                this._line.push(new TextChunk({\n                  wordWidth: font.stringWidth(subword, fontSize),\n                  spaceWidth: spaceWidth,\n                  word: subword,\n                  font: font,\n                  fontSize: fontSize,\n                  color: color,\n                  decoration: decoration,\n                  link: link,\n                  destination: destination,\n                  goTo: goTo\n                }));\n\n                offsetWidth -= w.width;\n                this._spaceLeft -= offsetWidth;\n                nextWord = word.slice(i);\n                word = null;\n                return _context4.abrupt(\"break\", 58);\n\n              case 55:\n                --i;\n                _context4.next = 45;\n                break;\n\n              case 58:\n                // if there is enough space, add word to the current line\n                if (!postponeLinebreak && word && this._spaceLeft - offsetWidth >= 0) {\n                  this._line.push(new TextChunk({\n                    wordWidth: wordWidth,\n                    spaceWidth: spaceWidth,\n                    word: word,\n                    font: font,\n                    fontSize: fontSize,\n                    color: color,\n                    decoration: decoration,\n                    link: link,\n                    destination: destination,\n                    goTo: goTo\n                  }));\n\n                  this._spaceLeft -= offsetWidth;\n                  word = null;\n                } // render line\n\n\n                left = this._cursor.x; // calc max line height\n\n                height = 0;\n                descent = 0;\n                _iterator = _createForOfIteratorHelper(this._line);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _w2 = _step.value;\n                    h = _w2.font.lineHeight(_w2.fontSize, true);\n\n                    if (h > height) {\n                      height = h;\n                    }\n\n                    d = -_w2.font.descent(_w2.fontSize);\n\n                    if (d > descent) {\n                      descent = d;\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                height *= lineHeight;\n                descent *= lineHeight;\n\n                if (height === 0) {\n                  height = this._previousHeight;\n                  descent = this._previousDescent;\n                } // break page if necessary\n\n\n                if (this._cursor.doesFit(height)) {\n                  _context4.next = 72;\n                  break;\n                }\n\n                return _context4.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                  var remainingText;\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (_this2._isFirstLine) {\n                            _context3.next = 3;\n                            break;\n                          }\n\n                          _context3.next = 3;\n                          return _this2._doc._write(ops.ET());\n\n                        case 3:\n                          // execute page break\n                          // add remaining text as new text to the queue of pending operations\n                          remainingText = bk ? (word ? word + ' ' : '') + text.substring(bk.position) : '';\n\n                          if (bk && bk.required) {\n                            // if the page break happened due to a line break, we have to make sure to add it back\n                            // to the queue as well\n                            remainingText += '\\n';\n                          }\n\n                          _this2._pending.unshift(function () {\n                            _this2._parts++;\n                            return _this2._render(remainingText, opts);\n                          });\n\n                          _context3.next = 8;\n                          return _this2._parent._pageBreak(1);\n\n                        case 8:\n                          _this2._isFirstLine = true;\n                          _this2._isNewLine = true;\n                          _this2._previousFont = null;\n                          _this2._previousFontSize = null;\n                          _this2._previousColor = null;\n                          return _context3.abrupt(\"return\", \"break\");\n\n                        case 14:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                })(), \"t0\", 69);\n\n              case 69:\n                _ret = _context4.t0;\n\n                if (!(_ret === \"break\")) {\n                  _context4.next = 72;\n                  break;\n                }\n\n                return _context4.abrupt(\"break\", 112);\n\n              case 72:\n                // shift cursor; since rendering is done above the y coordinate,\n                // we have to update the cursor before rendering the line\n                this._cursor.y -= height; // shift y cursor\n                // calculate remaining space\n\n                freeSpace = this._spaceLeft; // alignment\n\n                spacing = 0;\n                _context4.t1 = this.alignment;\n                _context4.next = _context4.t1 === 'right' ? 78 : _context4.t1 === 'center' ? 80 : _context4.t1 === 'justify' ? 82 : 87;\n                break;\n\n              case 78:\n                left += freeSpace;\n                return _context4.abrupt(\"break\", 87);\n\n              case 80:\n                left += this._cursor.width / 2 - (this._cursor.width - freeSpace) / 2;\n                return _context4.abrupt(\"break\", 87);\n\n              case 82:\n                isLastLine = isLastWord || bk && bk.required;\n\n                if (!(isLastLine && freeSpace / this._cursor.width > .2)) {\n                  _context4.next = 85;\n                  break;\n                }\n\n                return _context4.abrupt(\"break\", 87);\n\n              case 85:\n                if (this._line.length > 1) {\n                  spacing = freeSpace / (this._line.length - 1);\n                }\n\n                return _context4.abrupt(\"break\", 87);\n\n              case 87:\n                // render words\n                chunk = '';\n\n                if (this._isFirstLine) {\n                  this._previousHeight = height;\n                  chunk += ops.BT() // set initial pos\n                  + ops.Tm(1, 0, 0, 1, left, this._cursor.y) // set leading\n                  + ops.TL(this._previousHeight);\n                } else {\n                  lh = height + this._previousDescent;\n\n                  if (height > 0 && lh !== this._previousHeight) {\n                    this._previousHeight = lh;\n                    chunk += ops.TL(lh);\n                  }\n\n                  if (left > this._cursor.x) {\n                    // set new x and y position\n                    chunk += ops.Tm(1, 0, 0, 1, left, this._cursor.y);\n                  } else {\n                    // move to next line\n                    chunk += ops.Tstar();\n                  }\n                }\n\n                if (height > 0) {\n                  this._previousDescent = descent;\n                }\n\n                out = [];\n                rangeStyleArgs = [this._doc, left, this._cursor.y, height, spacing];\n                underlineStyle = _construct(UnderlineRangeStyle, rangeStyleArgs);\n                strikethroughStyle = _construct(StrikethroughRangeStyle, rangeStyleArgs);\n                linkStyle = _construct(LinkRangeStyle, rangeStyleArgs);\n                destinationStyle = _construct(DestinationRangeStyle, rangeStyleArgs);\n                goToStyle = _construct(GoToRangeStyle, rangeStyleArgs);\n                lastIx = this._line.length - 1;\n\n                for (_i = 0; _i < this._line.length; ++_i) {\n                  _w = this._line[_i];\n                  fontStyleChanged = _w.font !== this._previousFont || _w.fontSize !== this._previousFontSize;\n                  colorChanged = !util.rgbEqual(_w.color, this._previousColor);\n                  chunk += underlineStyle.applyStyle(_w, _i === lastIx, fontStyleChanged || colorChanged);\n                  chunk += strikethroughStyle.applyStyle(_w, _i === lastIx, fontStyleChanged || colorChanged);\n                  chunk += linkStyle.applyStyle(_w, _i === lastIx, fontStyleChanged || colorChanged);\n                  chunk += destinationStyle.applyStyle(_w, _i === lastIx, fontStyleChanged || colorChanged);\n                  chunk += goToStyle.applyStyle(_w, _i === lastIx, fontStyleChanged || colorChanged);\n\n                  if (fontStyleChanged || colorChanged) {\n                    if (out.length > 0) {\n                      chunk += ops.TJ(out);\n                    }\n\n                    if (fontStyleChanged) {\n                      this._previousFont = _w.font;\n                      this._previousFontSize = _w.fontSize;\n                      alias = this._doc._fontAlias(_w.font); // set font and font size\n\n                      chunk += ops.Tf(alias, _w.fontSize);\n                    } // set color if it has changed\n\n\n                    if (colorChanged) {\n                      this._previousColor = _w.color;\n                      chunk += ops.sc.apply(ops, _toConsumableArray(_w.color));\n                    }\n\n                    out.length = 0;\n                  }\n\n                  kerning = _w.wordWidth.kerning;\n\n                  if (kerning.length > 0) {\n                    pos = 0;\n\n                    for (_i2 = 0; _i2 < kerning.length; ++_i2) {\n                      _subword = _w.word.substring(pos, kerning[_i2].pos);\n                      out.push(_w.font.encode(_subword), kerning[_i2].offset);\n                      pos = kerning[_i2].pos;\n                    }\n\n                    out.push(_w.font.encode(_w.word.substring(pos)));\n                  } else {\n                    out.push(_w.font.encode(_w.word));\n                  }\n\n                  if (_i < this._line.length - 1 && _w.spaceWidth > 0) {\n                    // if is not last and has spaceWidth set\n                    out.push(calcSpaceWidth(spacing, _w.font, _w.fontSize));\n                  }\n                }\n\n                if (out.length > 0) {\n                  chunk += ops.TJ(out);\n                }\n\n                _context4.next = 102;\n                return this._doc._write(chunk);\n\n              case 102:\n                this._cursor.y -= descent; // reset / update variables\n\n                this._spaceLeft = this._cursor.width;\n                this._line.length = 0; // empty line array\n\n                this._isFirstLine = false;\n                this._isNewLine = bk && bk.required;\n                postponeLinebreak = bk && bk.required && word !== null && word.length > 0;\n\n              case 108:\n                // consider word for next line\n                if (word) {\n                  this._line.push(new TextChunk({\n                    wordWidth: wordWidth,\n                    spaceWidth: spaceWidth,\n                    word: word,\n                    font: font,\n                    fontSize: fontSize,\n                    color: color,\n                    decoration: decoration,\n                    link: link,\n                    destination: destination,\n                    goTo: goTo\n                  }));\n\n                  this._spaceLeft -= offsetWidth;\n                }\n\n                bk = null;\n                _context4.next = 18;\n                break;\n\n              case 112:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _render(_x, _x2) {\n        return _render2.apply(this, arguments);\n      }\n\n      return _render;\n    }() /// public API\n\n  }, {\n    key: \"add\",\n    value: function add(text, opts) {\n      var _this3 = this;\n\n      this._begin(null); // trigger error, if text is already ended\n\n\n      this._parts++;\n\n      this._pending.push(function () {\n        return _this3._render(text, opts || {});\n      });\n\n      return this;\n    }\n  }, {\n    key: \"append\",\n    value: function append(text, opts) {\n      var _this4 = this;\n\n      this._begin(null); // trigger error, if text is already ended\n\n\n      this._parts++;\n\n      this._pending.push(function () {\n        if (_this4._line.length > 0) {\n          var w = _this4._line[_this4._line.length - 1];\n          _this4._spaceLeft += w.spaceWidth;\n          w.spaceWidth = 0; // set space width to zero\n        }\n\n        return _this4._render(text, opts || {});\n      });\n\n      return this;\n    }\n  }, {\n    key: \"br\",\n    value: function br() {\n      var _this5 = this;\n\n      this._begin(null); // trigger error, if text is already ended\n\n\n      this._parts++;\n\n      this._pending.push(function () {\n        return _this5._render('\\n\\n', {});\n      });\n\n      return this;\n    }\n  }]);\n\n  return Text;\n}(Fragment);\n\nfunction calcSpaceWidth(spacing, font, fontSize) {\n  var scaleFactor = 1000 / fontSize;\n  return -(spacing + font.stringWidth(' ', fontSize)) * scaleFactor;\n}\n\nvar TextChunk = function TextChunk(values) {\n  _classCallCheck(this, TextChunk);\n\n  this.wordWidth = values.wordWidth;\n  this.spaceWidth = values.spaceWidth;\n  this.word = values.word;\n  this.font = values.font;\n  this.fontSize = values.fontSize;\n  this.color = values.color;\n  this.decoration = values.decoration;\n  this.link = values.link;\n  this.destination = values.destination;\n  this.goTo = values.goTo;\n};\n\nvar RangeStyle = /*#__PURE__*/function () {\n  function RangeStyle(doc, x, y, height, spacing) {\n    _classCallCheck(this, RangeStyle);\n\n    this.doc = doc;\n    this.from = x;\n    this.width = 0;\n    this.y = y;\n    this.height = height;\n    this.spacing = spacing;\n    this.isActive = false;\n    this.lastSpaceWidth = 0;\n  }\n\n  _createClass(RangeStyle, [{\n    key: \"applyStyle\",\n    value: function applyStyle(textChunk, isLast, fontStyleChanged) {\n      var shouldApply = this._active(textChunk);\n\n      var chunk = '';\n\n      if (shouldApply && !fontStyleChanged && this.isActive) {\n        this.width += this.lastSpaceWidth;\n      }\n\n      if (this.isActive && (!shouldApply || fontStyleChanged)) {\n        chunk += this._applyStyle(textChunk);\n        this.from += this.width + this.lastSpaceWidth;\n        this.width = 0;\n      }\n\n      if (!this.isActive || shouldApply || this.isActive && fontStyleChanged) {\n        this._start(textChunk);\n      }\n\n      this.isActive = shouldApply;\n      this.lastSpaceWidth = this.spacing || textChunk.spaceWidth;\n\n      if (this.isActive) {\n        this.width += textChunk.wordWidth;\n      } else {\n        this.from += textChunk.wordWidth + this.lastSpaceWidth;\n      }\n\n      if (this.isActive && isLast) {\n        chunk += this._applyStyle(textChunk);\n      }\n\n      return chunk;\n    }\n  }, {\n    key: \"_active\",\n    value: function _active(textChunk) {// abstract\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(textChunk) {// abstract\n    }\n  }, {\n    key: \"_applyStyle\",\n    value: function _applyStyle(textChunk) {// abstract\n    }\n  }]);\n\n  return RangeStyle;\n}();\n\nvar UnderlineRangeStyle = /*#__PURE__*/function (_RangeStyle) {\n  _inherits(UnderlineRangeStyle, _RangeStyle);\n\n  var _super2 = _createSuper(UnderlineRangeStyle);\n\n  function UnderlineRangeStyle(doc, x, y, height, spacing) {\n    var _this6;\n\n    _classCallCheck(this, UnderlineRangeStyle);\n\n    _this6 = _super2.call(this, doc, x, y, height, spacing);\n    _this6.underlinePosition = 0;\n    _this6.underlineThickness = 0;\n    _this6.color = null;\n    return _this6;\n  }\n\n  _createClass(UnderlineRangeStyle, [{\n    key: \"_active\",\n    value: function _active(textChunk) {\n      return textChunk.decoration & UNDERLINE_FLAG;\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(textChunk) {\n      this.underlinePosition = textChunk.font.underlinePosition(textChunk.fontSize);\n      this.underlineThickness = textChunk.font.underlineThickness(textChunk.fontSize);\n      this.color = textChunk.color;\n    }\n  }, {\n    key: \"_applyStyle\",\n    value: function _applyStyle(textChunk) {\n      var y = this.y + this.underlinePosition;\n      return ops.w(this.underlineThickness) // line width\n      + ops.SC.apply(ops, _toConsumableArray(this.color)) // stroking color\n      + ops.S(this.from, y, 'm', this.from + this.width, y, 'l'); // line\n    }\n  }]);\n\n  return UnderlineRangeStyle;\n}(RangeStyle);\n\nvar StrikethroughRangeStyle = /*#__PURE__*/function (_RangeStyle2) {\n  _inherits(StrikethroughRangeStyle, _RangeStyle2);\n\n  var _super3 = _createSuper(StrikethroughRangeStyle);\n\n  function StrikethroughRangeStyle(doc, x, y, height, spacing) {\n    var _this7;\n\n    _classCallCheck(this, StrikethroughRangeStyle);\n\n    _this7 = _super3.call(this, doc, x, y, height, spacing);\n    _this7.ascent = 0;\n    _this7.lineThickness = 0;\n    _this7.color = null;\n    return _this7;\n  }\n\n  _createClass(StrikethroughRangeStyle, [{\n    key: \"_active\",\n    value: function _active(textChunk) {\n      return textChunk.decoration & STRIKETHROUGH_FLAG;\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(textChunk) {\n      this.ascent = textChunk.font.ascent(textChunk.fontSize);\n      this.lineThickness = textChunk.font.underlineThickness(textChunk.fontSize);\n      this.color = textChunk.color;\n    }\n  }, {\n    key: \"_applyStyle\",\n    value: function _applyStyle(textChunk) {\n      var y = this.y + this.ascent * .35;\n      return ops.w(this.lineThickness) // line width\n      + ops.SC.apply(ops, _toConsumableArray(this.color)) // stroking color\n      + ops.S(this.from, y, 'm', this.from + this.width, y, 'l'); // line\n    }\n  }]);\n\n  return StrikethroughRangeStyle;\n}(RangeStyle);\n\nvar LinkRangeStyle = /*#__PURE__*/function (_RangeStyle3) {\n  _inherits(LinkRangeStyle, _RangeStyle3);\n\n  var _super4 = _createSuper(LinkRangeStyle);\n\n  function LinkRangeStyle(doc, x, y, height, spacing) {\n    var _this8;\n\n    _classCallCheck(this, LinkRangeStyle);\n\n    _this8 = _super4.call(this, doc, x, y, height, spacing);\n    _this8.link = null;\n    return _this8;\n  }\n\n  _createClass(LinkRangeStyle, [{\n    key: \"applyStyle\",\n    value: function applyStyle(textChunk, isLast, fontStyleChanged) {\n      if (this.link && textChunk.link !== this.link) {\n        fontStyleChanged = true;\n      }\n\n      return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n    }\n  }, {\n    key: \"_active\",\n    value: function _active(textChunk) {\n      return textChunk.link !== undefined;\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(textChunk) {\n      this.link = textChunk.link;\n    }\n  }, {\n    key: \"_applyStyle\",\n    value: function _applyStyle(textChunk) {\n      this.doc._annotations.push(new PDF.Dictionary({\n        Type: 'Annot',\n        Subtype: 'Link',\n        Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n        Border: new PDF.Array([0, 0, 0]),\n        A: new PDF.Dictionary({\n          Type: 'Action',\n          S: 'URI',\n          URI: new PDF.String(this.link)\n        })\n      }));\n\n      return '';\n    }\n  }]);\n\n  return LinkRangeStyle;\n}(RangeStyle);\n\nvar DestinationRangeStyle = /*#__PURE__*/function (_RangeStyle4) {\n  _inherits(DestinationRangeStyle, _RangeStyle4);\n\n  var _super5 = _createSuper(DestinationRangeStyle);\n\n  function DestinationRangeStyle(doc, x, y, height, spacing) {\n    var _this9;\n\n    _classCallCheck(this, DestinationRangeStyle);\n\n    _this9 = _super5.call(this, doc, x, y, height, spacing);\n    _this9.destination = null;\n    return _this9;\n  }\n\n  _createClass(DestinationRangeStyle, [{\n    key: \"applyStyle\",\n    value: function applyStyle(textChunk, isLast, fontStyleChanged) {\n      if (this.destination && textChunk.destination !== this.destination) {\n        fontStyleChanged = true;\n      }\n\n      return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n    }\n  }, {\n    key: \"_active\",\n    value: function _active(textChunk) {\n      return textChunk.destination !== undefined;\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(textChunk) {\n      this.destination = textChunk.destination;\n    }\n  }, {\n    key: \"_applyStyle\",\n    value: function _applyStyle(textChunk) {\n      this.doc._destinations.set(this.destination, new PDF.Array([this.doc._currentPage.toReference(), new PDF.Name('XYZ'), this.from, this.y, null]));\n\n      return '';\n    }\n  }]);\n\n  return DestinationRangeStyle;\n}(RangeStyle);\n\nvar GoToRangeStyle = /*#__PURE__*/function (_RangeStyle5) {\n  _inherits(GoToRangeStyle, _RangeStyle5);\n\n  var _super6 = _createSuper(GoToRangeStyle);\n\n  function GoToRangeStyle(doc, x, y, height, spacing) {\n    var _this10;\n\n    _classCallCheck(this, GoToRangeStyle);\n\n    _this10 = _super6.call(this, doc, x, y, height, spacing);\n    _this10.goTo = null;\n    return _this10;\n  }\n\n  _createClass(GoToRangeStyle, [{\n    key: \"applyStyle\",\n    value: function applyStyle(textChunk, isLast, fontStyleChanged) {\n      if (this.goTo && textChunk.goTo !== this.goTo) {\n        fontStyleChanged = true;\n      }\n\n      return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n    }\n  }, {\n    key: \"_active\",\n    value: function _active(textChunk) {\n      return textChunk.goTo !== undefined;\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(textChunk) {\n      this.goTo = textChunk.goTo;\n    }\n  }, {\n    key: \"_applyStyle\",\n    value: function _applyStyle(textChunk) {\n      this.doc._annotations.push(new PDF.Dictionary({\n        Type: 'Annot',\n        Subtype: 'Link',\n        Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n        Border: new PDF.Array([0, 0, 0]),\n        A: new PDF.Dictionary({\n          S: 'GoTo',\n          D: new PDF.String(this.goTo)\n        })\n      }));\n\n      return '';\n    }\n  }]);\n\n  return GoToRangeStyle;\n}(RangeStyle);\n\nText.DestinationRangeStyle = DestinationRangeStyle;","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/text.js"],"names":["Fragment","require","LineBreaker","unorm","ops","util","Font","PDF","UNDERLINE_FLAG","STRIKETHROUGH_FLAG","Text","module","exports","doc","parent","opts","_line","_spaceLeft","_parts","_isFirstLine","_isNewLine","_previousFont","_previousFontSize","_previousColor","_previousHeight","_previousDescent","defaultFont","font","_doc","defaultFontSize","fontSize","defaultColor","color","colorToRgb","defaultLineHeight","lineHeight","defaultDecoration","underline","strikethrough","alignment","textAlign","link","destination","goTo","_currentContent","_startPage","_cursor","width","_write","ET","text","isFont","TypeError","_fontInstance","decoration","String","replace","breaker","last","isLastTextChunk","_ended","postponeLinebreak","nextWord","bk","nextBreak","length","word","until","position","lastIsSpace","match","slice","nfc","wordWidth","offsetWidth","spaceWidth","stringWidth","isLastWord","notEnoughSpace","required","i","w","subword","push","TextChunk","left","x","height","descent","h","d","doesFit","remainingText","substring","_pending","unshift","_render","_parent","_pageBreak","y","freeSpace","spacing","isLastLine","chunk","BT","Tm","TL","lh","Tstar","out","rangeStyleArgs","underlineStyle","UnderlineRangeStyle","strikethroughStyle","StrikethroughRangeStyle","linkStyle","LinkRangeStyle","destinationStyle","DestinationRangeStyle","goToStyle","GoToRangeStyle","lastIx","fontStyleChanged","colorChanged","rgbEqual","applyStyle","TJ","alias","_fontAlias","Tf","sc","kerning","pos","encode","offset","calcSpaceWidth","_begin","scaleFactor","values","RangeStyle","from","isActive","lastSpaceWidth","textChunk","isLast","shouldApply","_active","_applyStyle","_start","underlinePosition","underlineThickness","SC","S","ascent","lineThickness","prototype","call","undefined","_annotations","Dictionary","Type","Subtype","Rect","Array","Border","A","URI","_destinations","set","_currentPage","toReference","Name","D"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Fragment = require('./fragment')\nconst LineBreaker = require('@rkusa/linebreak')\nconst unorm = require('unorm')\nconst ops = require('./ops')\nconst util = require('./util')\nconst Font = require('./font/base')\nconst PDF = require('./object')\n\nconst UNDERLINE_FLAG = 1\nconst STRIKETHROUGH_FLAG = 2\n\nconst Text = module.exports = class Text extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent)\n\n    this._line = []\n    this._spaceLeft = 0\n    this._parts = 0\n    this._isFirstLine = true\n    this._isNewLine = true\n\n    this._previousFont = null\n    this._previousFontSize = null\n    this._previousColor = null\n\n    this._previousHeight = 0\n    this._previousDescent = 0\n\n    this.opts = opts\n    this.defaultFont = opts.font || this._doc.defaultFont\n    this.defaultFontSize = opts.fontSize || this._doc.defaultFontSize\n    this.defaultColor = opts.color && util.colorToRgb(opts.color) || this._doc.defaultColor\n    this.defaultLineHeight = opts.lineHeight || this._doc.defaultLineHeight\n    this.defaultDecoration = (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0)\n\n    this.alignment = opts.alignment || opts.textAlign || 'left'\n\n    this.link = opts.link\n    this.destination = opts.destination\n    this.goTo = opts.goTo\n  }\n\n  /// private API\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage()\n    }\n\n    this._spaceLeft = this._cursor.width\n  }\n\n  async _end() {\n    // write end text\n    await this._doc._write(ops.ET())\n  }\n\n  async _render(text, opts) {\n    this._parts--\n\n    if (!Font.isFont(opts.font || this.defaultFont)) {\n      throw new TypeError('invalid font: ' + font)\n    }\n\n    const font = this._doc._fontInstance(opts.font || this.defaultFont)\n    const fontSize = opts.fontSize || this.defaultFontSize\n    const color = opts.color && util.colorToRgb(opts.color) || this.defaultColor\n    const lineHeight = opts.lineHeight || this.defaultLineHeight\n    const link = opts.link || this.link\n    const destination = opts.destination || this.destination\n    const goTo = opts.goTo || this.goTo\n    const decoration = this.defaultDecoration | (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0)\n\n    // enforce string\n    text = String(text)\n    text = text.replace(/\\r\\n/g, '\\n')\n               .replace(/\\u2028|\\u2029/g, '') // <- TODO: does this break things?\n\n    const breaker = new LineBreaker(text)\n    let last = 0, bk\n\n    const isLastTextChunk = this._parts === 0 && this._ended\n    let postponeLinebreak = false\n    let nextWord = null\n\n    while (nextWord !== null || postponeLinebreak || (bk = breaker.nextBreak()) || (isLastTextChunk && this._line.length > 0)) {\n      let word = null\n\n      if (nextWord) {\n        word = nextWord\n        nextWord = null\n      }\n      // when there is no break, there is an orphan word that just has to be rendered,\n      // i.e., skip to the line rendering\n      else if (bk) {\n        let until = bk.position\n\n        const lastIsSpace = text[bk.position - 1].match(/\\s/)\n        if (lastIsSpace) {\n          until--\n        }\n\n        // get the string between the last break and this one\n        word = text.slice(last, until)\n\n        // separate words, if has whitespace, is at the end of the text or\n        // ends with a whitespace\n        if (bk.position === text.length || lastIsSpace) {\n          last = bk.position\n        } else {\n          continue\n        }\n\n        word = unorm.nfc(word)\n      }\n\n      let wordWidth = 0\n      let offsetWidth = 0\n      let spaceWidth = 0\n\n      if (word) {\n        wordWidth = font.stringWidth(word, fontSize)\n        offsetWidth = wordWidth.width\n        spaceWidth = font.stringWidth(' ', fontSize).width\n\n        // add whitespace length for every word, except the first on in the line\n        // on the first line, during the first word the line array is empty, however, for succeeding\n        // lines the line array already contains the word that did not fit into the previous line\n        if (this._line.length > (this._isNewLine ? 0 : 1)) {\n          offsetWidth += spaceWidth\n        }\n      }\n\n      // render line if there is a line break, if we hit the last word of the text, if we\n      // have manual page breaks, or if there is not enough space on the line left\n      const isLastWord = (!bk || bk.position === text.length) && isLastTextChunk\n      const notEnoughSpace = this._spaceLeft < offsetWidth\n      if (postponeLinebreak || (bk && bk.required) || isLastWord || notEnoughSpace) {\n        // if word is longer than one line\n        if (this._line.length === 0 && notEnoughSpace) {\n          // split word\n          for (let i = word.length - 1; i >= 0; --i) {\n            const w = font.stringWidth(word.slice(i), fontSize)\n\n            if (this._spaceLeft >= offsetWidth - w.width) {\n              const subword = word.slice(0, i)\n              this._line.push(\n                new TextChunk({\n                  wordWidth: font.stringWidth(subword, fontSize),\n                  spaceWidth, word: subword,\n                  font, fontSize, color, decoration,\n                  link, destination, goTo\n                })\n              )\n              offsetWidth -= w.width\n              this._spaceLeft -= offsetWidth\n\n              nextWord = word.slice(i)\n              word = null\n\n              break\n            }\n          }\n        }\n\n        // if there is enough space, add word to the current line\n        if (!postponeLinebreak && word && (this._spaceLeft - offsetWidth) >= 0) {\n          this._line.push(\n            new TextChunk({\n              wordWidth, spaceWidth, word, font, fontSize,\n              color, decoration,\n              link, destination, goTo\n            })\n          )\n          this._spaceLeft -= offsetWidth\n          word = null\n        }\n\n        // render line\n        let left = this._cursor.x\n\n        // calc max line height\n        let height = 0\n        let descent = 0\n\n        for (const w of this._line) {\n          const h = w.font.lineHeight(w.fontSize, true)\n          if (h > height) {\n            height = h\n          }\n\n          const d = -w.font.descent(w.fontSize)\n          if (d > descent) {\n            descent = d\n          }\n        }\n\n        height *= lineHeight\n        descent *= lineHeight\n\n        if (height === 0) {\n          height = this._previousHeight\n          descent = this._previousDescent\n        }\n\n        // break page if necessary\n        if (!this._cursor.doesFit(height)) {\n          if (!this._isFirstLine) {\n            await this._doc._write(ops.ET())\n          }\n\n          // execute page break\n          // add remaining text as new text to the queue of pending operations\n          let remainingText = bk ? ((word ? (word + ' ') : '') + text.substring(bk.position)) : ''\n          if (bk && bk.required) {\n            // if the page break happened due to a line break, we have to make sure to add it back\n            // to the queue as well\n            remainingText += '\\n';\n          }\n\n          this._pending.unshift(() => {\n            this._parts++\n            return this._render(remainingText, opts)\n          })\n\n          await this._parent._pageBreak(1)\n\n          this._isFirstLine = true\n          this._isNewLine = true\n          this._previousFont = null\n          this._previousFontSize = null\n          this._previousColor = null\n\n          break\n        }\n\n        // shift cursor; since rendering is done above the y coordinate,\n        // we have to update the cursor before rendering the line\n        this._cursor.y -= height // shift y cursor\n\n        // calculate remaining space\n        const freeSpace = this._spaceLeft\n\n        // alignment\n        let spacing = 0\n        switch (this.alignment) {\n        case 'right':\n          left += freeSpace\n          break\n        case 'center':\n          left += this._cursor.width / 2 - (this._cursor.width - freeSpace) / 2\n          break\n        case 'justify':\n          const isLastLine = isLastWord || (bk && bk.required)\n          if (isLastLine && freeSpace / this._cursor.width > .2) {\n            break\n          }\n          if (this._line.length > 1) {\n            spacing = freeSpace / (this._line.length - 1)\n          }\n          break\n        }\n\n        // render words\n        let chunk = ''\n\n        if (this._isFirstLine) {\n          this._previousHeight = height\n          chunk += ops.BT()\n                // set initial pos\n                + ops.Tm(1, 0, 0, 1, left, this._cursor.y)\n                // set leading\n                + ops.TL(this._previousHeight)\n        } else {\n          const lh = height + this._previousDescent\n\n          if (height > 0 && lh !== this._previousHeight) {\n            this._previousHeight = lh\n            chunk += ops.TL(lh)\n          }\n\n          if (left > this._cursor.x) {\n            // set new x and y position\n            chunk += ops.Tm(1, 0, 0, 1, left, this._cursor.y)\n          } else {\n            // move to next line\n            chunk += ops.Tstar()\n          }\n        }\n\n        if (height > 0) {\n          this._previousDescent = descent\n        }\n\n        const out = []\n\n        const rangeStyleArgs = [this._doc, left, this._cursor.y, height, spacing]\n        const underlineStyle = new UnderlineRangeStyle(...rangeStyleArgs)\n        const strikethroughStyle = new StrikethroughRangeStyle(...rangeStyleArgs)\n        const linkStyle = new LinkRangeStyle(...rangeStyleArgs)\n        const destinationStyle = new DestinationRangeStyle(...rangeStyleArgs)\n        const goToStyle = new GoToRangeStyle(...rangeStyleArgs)\n\n        const lastIx = this._line.length - 1\n        for (let i = 0; i < this._line.length; ++i) {\n          const w = this._line[i]\n\n          const fontStyleChanged = w.font !== this._previousFont || w.fontSize !== this._previousFontSize\n          const colorChanged = !util.rgbEqual(w.color, this._previousColor)\n\n          chunk += underlineStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += strikethroughStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += linkStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += destinationStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += goToStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n\n          if (fontStyleChanged || colorChanged) {\n            if (out.length > 0) {\n              chunk += ops.TJ(out)\n            }\n\n            if (fontStyleChanged) {\n              this._previousFont = w.font\n              this._previousFontSize = w.fontSize\n\n              const alias = this._doc._fontAlias(w.font)\n\n              // set font and font size\n              chunk += ops.Tf(alias, w.fontSize)\n            }\n\n            // set color if it has changed\n            if (colorChanged) {\n              this._previousColor = w.color\n              chunk += ops.sc(...w.color)\n            }\n\n            out.length = 0\n          }\n\n          const kerning = w.wordWidth.kerning\n          if (kerning.length > 0) {\n            let pos = 0\n            for (let i = 0; i < kerning.length; ++i) {\n              let subword = w.word.substring(pos, kerning[i].pos)\n              out.push(w.font.encode(subword), kerning[i].offset)\n              pos = kerning[i].pos\n            }\n            out.push(w.font.encode(w.word.substring(pos)))\n          } else {\n            out.push(w.font.encode(w.word))\n          }\n\n          if (i < this._line.length - 1 && w.spaceWidth > 0) {\n            // if is not last and has spaceWidth set\n            out.push(calcSpaceWidth(spacing, w.font, w.fontSize))\n          }\n        }\n        if (out.length > 0) {\n          chunk += ops.TJ(out)\n        }\n\n        await this._doc._write(chunk)\n\n        this._cursor.y -= descent\n\n        // reset / update variables\n        this._spaceLeft = this._cursor.width\n        this._line.length = 0 // empty line array\n        this._isFirstLine = false\n        this._isNewLine = bk && bk.required\n\n        postponeLinebreak = bk && bk.required && word !== null && word.length > 0\n      }\n\n      // consider word for next line\n      if (word) {\n        this._line.push(\n          new TextChunk({\n            wordWidth, spaceWidth, word, font, fontSize,\n            color, decoration,\n            link, destination, goTo\n          })\n        )\n\n        this._spaceLeft -= offsetWidth\n      }\n\n      bk = null\n    }\n  }\n\n  /// public API\n\n  add(text, opts) {\n    this._begin(null) // trigger error, if text is already ended\n    this._parts++\n    this._pending.push(() => this._render(text, opts || {}))\n\n    return this\n  }\n\n  append(text, opts) {\n    this._begin(null) // trigger error, if text is already ended\n\n    this._parts++\n    this._pending.push(() => {\n      if (this._line.length > 0) {\n        const w = this._line[this._line.length - 1]\n        this._spaceLeft += w.spaceWidth\n        w.spaceWidth = 0 // set space width to zero\n      }\n      return this._render(text, opts || {})\n    })\n\n    return this\n  }\n\n  br() {\n    this._begin(null) // trigger error, if text is already ended\n\n    this._parts++\n    this._pending.push(() => this._render('\\n\\n', {}))\n\n    return this\n  }\n}\n\nfunction calcSpaceWidth(spacing, font, fontSize) {\n  const scaleFactor = 1000 / fontSize\n  return -(spacing + font.stringWidth(' ', fontSize)) * scaleFactor\n}\n\nclass TextChunk {\n  constructor(values) {\n    this.wordWidth = values.wordWidth\n    this.spaceWidth = values.spaceWidth\n    this.word = values.word\n    this.font = values.font\n    this.fontSize = values.fontSize\n    this.color = values.color\n    this.decoration = values.decoration\n    this.link = values.link\n    this.destination = values.destination\n    this.goTo = values.goTo\n  }\n}\n\nclass RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    this.doc = doc\n    this.from = x\n    this.width = 0\n    this.y = y\n    this.height = height\n    this.spacing = spacing\n    this.isActive = false\n    this.lastSpaceWidth = 0\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    const shouldApply = this._active(textChunk)\n    let chunk = ''\n\n    if (shouldApply && !fontStyleChanged && this.isActive) {\n      this.width += this.lastSpaceWidth\n    }\n\n    if (this.isActive && (!shouldApply || fontStyleChanged)) {\n      chunk += this._applyStyle(textChunk)\n      this.from += this.width + this.lastSpaceWidth\n      this.width = 0\n    }\n\n    if ((!this.isActive || shouldApply) || this.isActive && fontStyleChanged) {\n      this._start(textChunk)\n    }\n\n    this.isActive = shouldApply\n    this.lastSpaceWidth = this.spacing || textChunk.spaceWidth\n    if (this.isActive) {\n      this.width += textChunk.wordWidth\n    } else {\n      this.from += textChunk.wordWidth + this.lastSpaceWidth\n    }\n\n    if (this.isActive && isLast) {\n      chunk += this._applyStyle(textChunk)\n    }\n\n    return chunk\n  }\n\n  _active(textChunk) {\n    // abstract\n  }\n\n  _start(textChunk) {\n    // abstract\n  }\n\n  _applyStyle(textChunk) {\n    // abstract\n  }\n}\n\nclass UnderlineRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.underlinePosition = 0\n    this.underlineThickness = 0\n    this.color = null\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & UNDERLINE_FLAG\n  }\n\n  _start(textChunk) {\n    this.underlinePosition = textChunk.font.underlinePosition(textChunk.fontSize)\n    this.underlineThickness = textChunk.font.underlineThickness(textChunk.fontSize)\n    this.color = textChunk.color\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.underlinePosition\n    return ops.w(this.underlineThickness)  // line width\n         + ops.SC(...this.color) // stroking color\n         + ops.S(this.from, y, 'm', this.from + this.width, y, 'l') // line\n  }\n}\n\nclass StrikethroughRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.ascent = 0\n    this.lineThickness = 0\n    this.color = null\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & STRIKETHROUGH_FLAG\n  }\n\n  _start(textChunk) {\n    this.ascent = textChunk.font.ascent(textChunk.fontSize)\n    this.lineThickness = textChunk.font.underlineThickness(textChunk.fontSize)\n    this.color = textChunk.color\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.ascent * .35\n    return ops.w(this.lineThickness)  // line width\n         + ops.SC(...this.color) // stroking color\n         + ops.S(this.from, y, 'm', this.from + this.width, y, 'l') // line\n  }\n}\n\nclass LinkRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.link = null\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.link && textChunk.link !== this.link) {\n      fontStyleChanged = true\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged)\n  }\n\n  _active(textChunk) {\n    return textChunk.link !== undefined\n  }\n\n  _start(textChunk) {\n    this.link = textChunk.link\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: 'Annot',\n      Subtype: 'Link',\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        Type: 'Action',\n        S: 'URI',\n        URI: new PDF.String(this.link),\n      }),\n    }))\n    return ''\n  }\n}\n\nclass DestinationRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.destination = null\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.destination && textChunk.destination !== this.destination) {\n      fontStyleChanged = true\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged)\n  }\n\n  _active(textChunk) {\n    return textChunk.destination !== undefined\n  }\n\n  _start(textChunk) {\n    this.destination = textChunk.destination\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._destinations.set(this.destination, new PDF.Array([\n      this.doc._currentPage.toReference(),\n      new PDF.Name('XYZ'),\n      this.from,\n      this.y,\n      null,\n    ]))\n    return ''\n  }\n}\n\nclass GoToRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.goTo = null\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.goTo && textChunk.goTo !== this.goTo) {\n      fontStyleChanged = true\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged)\n  }\n\n  _active(textChunk) {\n    return textChunk.goTo !== undefined\n  }\n\n  _start(textChunk) {\n    this.goTo = textChunk.goTo\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: 'Annot',\n      Subtype: 'Link',\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        S: 'GoTo',\n        D: new PDF.String(this.goTo),\n      }),\n    }))\n    return ''\n  }\n}\n\nText.DestinationRangeStyle = DestinationRangeStyle\n"]},"metadata":{},"sourceType":"script"}