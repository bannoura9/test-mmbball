{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar util = require('../util');\n\nvar PDFReference = /*#__PURE__*/function () {\n  function PDFReference(obj) {\n    _classCallCheck(this, PDFReference);\n\n    Object.defineProperty(this, 'object', {\n      enumerable: true,\n      get: function get() {\n        if (!obj) {\n          return undefined;\n        }\n\n        if (typeof obj === 'function') {\n          obj = obj();\n        }\n\n        return obj;\n      }\n    });\n  }\n\n  _createClass(PDFReference, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.object.id + ' ' + this.object.rev + ' R';\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(xref, lexer, trial) {\n      var before = lexer.pos;\n      var id = lexer.readNumber(trial);\n\n      if (id === undefined && !trial) {\n        throw new Error('Invalid indirect');\n      }\n\n      lexer.skipWhitespace(1, trial);\n      var generation = lexer.readNumber(trial);\n\n      if (generation === undefined && !trial) {\n        throw new Error('Invalid indirect');\n      }\n\n      lexer.skipWhitespace(1, trial);\n\n      if (lexer.getString(1) !== 'R') {\n        if (trial) {\n          lexer.pos = before;\n          return undefined;\n        }\n\n        throw new Error('Invalid indirect');\n      }\n\n      lexer.shift(1);\n\n      if (!lexer.state.references) {\n        lexer.state.references = new Map();\n      }\n\n      var key = \"\".concat(id, \" \").concat(generation);\n\n      if (lexer.state.references.has(key)) {\n        return lexer.state.references.get(key);\n      }\n\n      var ref = new PDFReference(parseObject.bind(null, xref, lexer.outer, id));\n      lexer.state.references.set(key, ref);\n      return ref;\n    }\n  }]);\n\n  return PDFReference;\n}();\n\nmodule.exports = PDFReference;\n\nfunction parseObject(xref, lexer, id) {\n  var PDFObject = require('./object');\n\n  var Lexer = require('../parser/lexer');\n\n  var obj = xref.get(id);\n\n  if (obj) {\n    return obj;\n  }\n\n  var offset = xref.getOffset(id);\n\n  if (offset === null) {\n    var entry = xref.objects[id];\n\n    if (entry.compressed) {\n      if (!entry.obj) {\n        lexer.pos = xref.getOffset(entry.id);\n\n        var _obj = PDFObject.parse(xref, lexer);\n\n        var type = _obj.properties.get('Type');\n\n        if (type && type.name !== 'ObjStm') {\n          throw new Error('Expected compressed object stream');\n        }\n\n        var src = util.inflate(_obj); // console.log(\"STRING: \", String.fromCharCode.apply(null, src))\n\n        var innerLexer = new Lexer(src, lexer);\n        _obj.lexer = innerLexer;\n        _obj.innerObjects = [];\n\n        var n = _obj.properties.get(\"N\");\n\n        for (var i = 0; i < n; ++i) {\n          var _id = innerLexer.readNumber(false);\n\n          innerLexer.skipSpace(1, false);\n\n          var _offset = innerLexer.readNumber(false);\n\n          innerLexer.skipWhitespace(1, true);\n\n          _obj.innerObjects.push({\n            id: _id,\n            offset: _offset,\n            obj: null\n          });\n        }\n\n        entry.obj = _obj;\n      }\n\n      var inner = entry.obj.innerObjects[entry.ix];\n\n      if (!inner.obj) {\n        var _innerLexer = entry.obj.lexer;\n        _innerLexer.pos = entry.obj.properties.get('First') + inner.offset;\n        inner.obj = PDFObject.parseInner(xref, _innerLexer);\n      }\n\n      return inner.obj;\n    } else {\n      throw new Error('Expected compressed object stream');\n    }\n  } else {\n    lexer.pos = offset;\n    return PDFObject.parse(xref, lexer);\n  }\n}","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/object/reference.js"],"names":["util","require","PDFReference","obj","Object","defineProperty","enumerable","get","undefined","object","id","rev","xref","lexer","trial","before","pos","readNumber","Error","skipWhitespace","generation","getString","shift","state","references","Map","key","has","ref","parseObject","bind","outer","set","module","exports","PDFObject","Lexer","offset","getOffset","entry","objects","compressed","parse","type","properties","name","src","inflate","innerLexer","innerObjects","n","i","skipSpace","push","inner","ix","parseInner"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('../util')\n\nclass PDFReference {\n  constructor(obj) {\n    Object.defineProperty(this, 'object', {\n      enumerable: true,\n      get: () => {\n        if (!obj) {\n          return undefined\n        }\n\n        if (typeof obj === 'function') {\n          obj = obj()\n        }\n\n        return obj\n      }\n    })\n  }\n\n  toString() {\n    return this.object.id + ' ' + this.object.rev + ' R'\n  }\n\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos\n\n    const id = lexer.readNumber(trial)\n    if (id === undefined && !trial) {\n      throw new Error('Invalid indirect')\n    }\n\n    lexer.skipWhitespace(1, trial)\n    const generation = lexer.readNumber(trial)\n    if (generation === undefined && !trial) {\n      throw new Error('Invalid indirect')\n    }\n\n    lexer.skipWhitespace(1, trial)\n    if (lexer.getString(1) !== 'R') {\n      if (trial) {\n        lexer.pos = before\n        return undefined\n      }\n\n      throw new Error('Invalid indirect')\n    }\n\n    lexer.shift(1)\n\n    if (!lexer.state.references) {\n      lexer.state.references = new Map()\n    }\n    const key = `${id} ${generation}`\n    if (lexer.state.references.has(key)) {\n      return lexer.state.references.get(key)\n    }\n\n    const ref = new PDFReference(parseObject.bind(null, xref, lexer.outer, id))\n    lexer.state.references.set(key, ref)\n    return ref\n  }\n}\n\nmodule.exports = PDFReference\n\nfunction parseObject(xref, lexer, id) {\n  const PDFObject = require('./object')\n  const Lexer = require('../parser/lexer')\n\n  const obj = xref.get(id)\n  if (obj) {\n    return obj\n  }\n\n  const offset = xref.getOffset(id)\n  if (offset === null) {\n    const entry = xref.objects[id]\n    if (entry.compressed) {\n      if (!entry.obj) {\n        lexer.pos = xref.getOffset(entry.id)\n        const obj = PDFObject.parse(xref, lexer)\n\n        const type = obj.properties.get('Type')\n        if (type && type.name !== 'ObjStm') {\n          throw new Error('Expected compressed object stream')\n        }\n\n        const src = util.inflate(obj)\n        // console.log(\"STRING: \", String.fromCharCode.apply(null, src))\n        const innerLexer = new Lexer(src, lexer)\n\n        obj.lexer = innerLexer\n        obj.innerObjects = []\n        const n = obj.properties.get(\"N\")\n        for (let i = 0; i < n; ++i) {\n          const id = innerLexer.readNumber(false)\n          innerLexer.skipSpace(1, false)\n          const offset = innerLexer.readNumber(false)\n          innerLexer.skipWhitespace(1, true)\n\n          obj.innerObjects.push({\n            id: id,\n            offset: offset,\n            obj: null,\n          })\n        }\n\n        entry.obj = obj\n      }\n\n      const inner = entry.obj.innerObjects[entry.ix]\n      if (!inner.obj) {\n        const innerLexer = entry.obj.lexer\n        innerLexer.pos = entry.obj.properties.get('First') + inner.offset\n\n        inner.obj = PDFObject.parseInner(xref, innerLexer)\n      }\n\n      return inner.obj\n    } else {\n      throw new Error('Expected compressed object stream')\n    }\n  } else {\n    lexer.pos = offset\n    return PDFObject.parse(xref, lexer)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}