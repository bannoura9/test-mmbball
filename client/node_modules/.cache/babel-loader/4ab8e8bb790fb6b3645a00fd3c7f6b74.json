{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PDFDictionary = require('./dictionary');\n\nvar PDFReference = require('./reference');\n\nvar PDFValue = require('./value');\n\nvar PDFObject = /*#__PURE__*/function () {\n  function PDFObject(type) {\n    _classCallCheck(this, PDFObject);\n\n    this.id = null;\n    this.rev = 0;\n    this.properties = new PDFDictionary();\n    this.reference = new PDFReference(this);\n    this.content = null;\n\n    if (type) {\n      this.prop('Type', type);\n    } // TODO: still necessary?\n    // used to have obj.object API for both indirect and direct objects\n    //   this.object = this\n\n  }\n\n  _createClass(PDFObject, [{\n    key: \"prop\",\n    value: function prop(key, val) {\n      this.properties.add(key, val);\n    }\n  }, {\n    key: \"toReference\",\n    value: function toReference() {\n      return this.reference;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.id.toString() + ' ' + this.rev + ' obj\\n' + (this.properties.length ? this.properties.toString() + '\\n' : '') + (this.content !== null ? this.content.toString() + '\\n' : '') + 'endobj';\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(xref, lexer, trial) {\n      var before = lexer.pos;\n      lexer.skipWhitespace(null, true);\n      var id = lexer.readNumber(trial);\n\n      if (id === undefined && !trial) {\n        throw new Error('Invalid object');\n      }\n\n      lexer.skipWhitespace(1, trial);\n      var generation = lexer.readNumber(trial);\n\n      if (generation === undefined && !trial) {\n        throw new Error('Invalid object');\n      }\n\n      lexer.skipWhitespace(1, trial);\n\n      if (lexer.getString(3) !== 'obj') {\n        if (trial) {\n          lexer.pos = before;\n          return undefined;\n        }\n\n        throw new Error('Invalid object');\n      }\n\n      lexer.shift(3);\n      lexer.skipEOL(1, true);\n      lexer.skipWhitespace(null, true);\n      var obj = PDFObject.parseInner(xref, lexer);\n      lexer.skipWhitespace(null, true);\n\n      if (lexer.readString(3) !== 'end') {\n        throw new Error('Invalid object: `end` not found');\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"parseInner\",\n    value: function parseInner(xref, lexer) {\n      var value = PDFValue.parse(xref, lexer, true);\n\n      if (value === undefined) {\n        throw new Error('Empty object');\n      }\n\n      lexer.skipWhitespace(null, true);\n      var obj = new PDFObject();\n\n      if (value instanceof PDFDictionary) {\n        obj.properties = value;\n\n        if (lexer.getString(6) === 'stream') {\n          lexer.shift(6);\n          lexer.skipEOL(1);\n          var length = obj.properties.get('Length');\n\n          if (length === undefined) {\n            throw new Error('Invalid Stream: no length specified');\n          }\n\n          if (typeof length === 'object') {\n            var pos = lexer.pos;\n            length = length.object.content;\n            lexer.pos = pos;\n          }\n\n          var PDFStream = require('./stream'); // lazy load, cause circular referecnes\n\n\n          var stream = new PDFStream(obj);\n          stream.content = lexer.read(length);\n          lexer.skipEOL(1, true); // not to be expected according to the PDF spec, but there are some PDF files that indent\n          // the stream\n\n          lexer.skipWhitespace(null, true);\n\n          if (lexer.readString(9) !== 'endstream') {\n            throw new Error('Invalid stream: `endstream` not found');\n          }\n\n          lexer.skipEOL(1, true);\n        }\n      } else {\n        obj.content = value;\n      }\n\n      return obj;\n    }\n  }]);\n\n  return PDFObject;\n}();\n\nmodule.exports = PDFObject;","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/object/object.js"],"names":["PDFDictionary","require","PDFReference","PDFValue","PDFObject","type","id","rev","properties","reference","content","prop","key","val","add","toString","length","xref","lexer","trial","before","pos","skipWhitespace","readNumber","undefined","Error","generation","getString","shift","skipEOL","obj","parseInner","readString","value","parse","get","object","PDFStream","stream","read","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PDFDictionary = require('./dictionary')\nconst PDFReference  = require('./reference')\nconst PDFValue = require('./value')\n\nclass PDFObject {\n  constructor(type) {\n    this.id         = null\n    this.rev        = 0\n    this.properties = new PDFDictionary()\n    this.reference  = new PDFReference(this)\n    this.content    = null\n\n    if (type) {\n      this.prop('Type', type)\n    }\n\n    // TODO: still necessary?\n    // used to have obj.object API for both indirect and direct objects\n    //   this.object = this\n  }\n\n  prop(key, val) {\n    this.properties.add(key, val)\n  }\n\n  toReference() {\n    return this.reference\n  }\n\n  toString() {\n    return this.id.toString() + ' ' + this.rev + ' obj\\n' +\n           (this.properties.length ? this.properties.toString() + '\\n' : '') +\n           (this.content !== null ? this.content.toString() + '\\n' : '') +\n           'endobj'\n  }\n\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos\n\n    lexer.skipWhitespace(null, true)\n    const id = lexer.readNumber(trial)\n    if (id === undefined && !trial) {\n      throw new Error('Invalid object')\n    }\n    lexer.skipWhitespace(1, trial)\n    const generation = lexer.readNumber(trial)\n    if (generation === undefined && !trial) {\n      throw new Error('Invalid object')\n    }\n\n    lexer.skipWhitespace(1, trial)\n    if (lexer.getString(3) !== 'obj') {\n      if (trial) {\n        lexer.pos = before\n        return undefined\n      }\n\n      throw new Error('Invalid object')\n    }\n\n    lexer.shift(3)\n\n    lexer.skipEOL(1, true)\n    lexer.skipWhitespace(null, true)\n\n    const obj = PDFObject.parseInner(xref, lexer)\n\n    lexer.skipWhitespace(null, true)\n\n    if (lexer.readString(3) !== 'end') {\n      throw new Error('Invalid object: `end` not found')\n    }\n\n    return obj\n  }\n\n  static parseInner(xref, lexer) {\n    const value = PDFValue.parse(xref, lexer, true)\n    if (value === undefined) {\n      throw new Error('Empty object')\n    }\n\n    lexer.skipWhitespace(null, true)\n\n    const obj = new PDFObject()\n    if (value instanceof PDFDictionary) {\n      obj.properties = value\n\n      if (lexer.getString(6) === 'stream') {\n        lexer.shift(6)\n        lexer.skipEOL(1)\n\n        let length = obj.properties.get('Length')\n        if (length === undefined) {\n          throw new Error('Invalid Stream: no length specified')\n        }\n\n        if (typeof length === 'object') {\n          const pos = lexer.pos\n          length = length.object.content\n          lexer.pos = pos\n        }\n\n        const PDFStream = require('./stream') // lazy load, cause circular referecnes\n        const stream = new PDFStream(obj)\n        stream.content = lexer.read(length)\n        lexer.skipEOL(1, true)\n\n        // not to be expected according to the PDF spec, but there are some PDF files that indent\n        // the stream\n        lexer.skipWhitespace(null, true)\n\n        if (lexer.readString(9) !== 'endstream') {\n          throw new Error('Invalid stream: `endstream` not found')\n        }\n\n        lexer.skipEOL(1, true)\n      }\n    } else {\n      obj.content = value\n    }\n\n    return obj\n  }\n}\n\nmodule.exports = PDFObject\n"]},"metadata":{},"sourceType":"script"}