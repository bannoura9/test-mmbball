{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Lexer = require('../parser/lexer');\n\nvar PDFString = /*#__PURE__*/function () {\n  function PDFString(str) {\n    _classCallCheck(this, PDFString);\n\n    this.str = str;\n  }\n\n  _createClass(PDFString, [{\n    key: \"toHexString\",\n    value: function toHexString() {\n      // convert to hex string\n      var hex = '';\n\n      for (var i = 0, len = this.str.length; i < len; ++i) {\n        var h = (this.str.charCodeAt(i) - 31).toString(16); // left pad zeroes\n\n        h = ('0000' + h).slice(-4);\n        hex += h;\n      }\n\n      return '<' + hex + '>';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '(' + this.str.replace(/\\\\/g, '\\\\\\\\').replace(/\\(/g, '\\\\(').replace(/\\)/g, '\\\\)') + ')';\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(xref, lexer, trial) {\n      var literal = PDFString.parseLiteral(lexer, trial);\n      var hex = literal === undefined && PDFString.parseHex(lexer, trial);\n\n      if (!literal && !hex) {\n        if (trial) {\n          return undefined;\n        }\n\n        throw new Error('Invalid string');\n      }\n\n      return literal || hex;\n    }\n  }, {\n    key: \"parseLiteral\",\n    value: function parseLiteral(lexer, trial) {\n      if (lexer.getString(1) !== '(') {\n        if (trial) {\n          return undefined;\n        }\n\n        throw new Error('Invalid literal string');\n      }\n\n      lexer.shift(1);\n      var str = '';\n      var done = false;\n      var open = 0;\n      var c;\n\n      while (!done && (c = lexer._nextCharCode()) >= 0) {\n        switch (c) {\n          case 0x28:\n            // (\n            open++;\n            str += String.fromCharCode('(');\n            break;\n\n          case 0x29:\n            // )\n            if (open === 0) {\n              done = true;\n            } else {\n              open--;\n              str += String.fromCharCode(')');\n            }\n\n            break;\n\n          case 0x5c:\n            // \\\n            c = lexer._nextCharCode();\n\n            switch (c) {\n              case 0x6e:\n                // \\n\n                str += '\\n';\n                break;\n\n              case 0x72:\n                // \\r\n                str += '\\r';\n                break;\n\n              case 0x74:\n                // \\t\n                str += '\\t';\n                break;\n\n              case 0x62:\n                // \\b\n                str += '\\b';\n                break;\n\n              case 0x66:\n                // \\f\n                str += '\\f';\n                break;\n\n              case 0x28: // '('\n\n              case 0x29: // ')'\n\n              case 0x5c:\n                // '\\'\n                str += String.fromCharCode(c);\n                break;\n\n              case 0x30: // 0\n\n              case 0x31: // 1\n\n              case 0x32: // 2\n\n              case 0x33: // 3\n\n              case 0x34: // 4\n\n              case 0x35: // 5\n\n              case 0x36: // 6\n\n              case 0x37: // 7\n\n              case 0x38: // 8\n\n              case 0x39:\n                // 9\n                var oct = String.fromCharCode(c) + lexer.readString(2);\n                str += String.fromCharCode(parseInt(oct, 8));\n                break;\n\n              default:\n                lexer.shift(-1);\n                break;\n            }\n\n            break;\n\n          case 0x0d: // CR\n\n          case 0x0a:\n            // LF\n            // ignore EOL characters\n            break;\n\n          default:\n            str += String.fromCharCode(c);\n            break;\n        }\n      }\n\n      return new PDFString(str);\n    }\n  }, {\n    key: \"parseHex\",\n    value: function parseHex(lexer, trial) {\n      if (lexer.getString(1) !== '<') {\n        if (trial) {\n          return undefined;\n        }\n\n        throw new Error('Invalid hex string');\n      }\n\n      lexer.shift(1);\n      var str = '';\n      var done = false;\n      var digits = [];\n\n      var addCharacter = function addCharacter(force) {\n        if (digits.length !== 2) {\n          if (digits.length === 1 && force) {\n            digits.push('0');\n          } else {\n            return;\n          }\n        }\n\n        str += String.fromCharCode(parseInt(digits.join(''), 16));\n        digits.length = 0;\n      };\n\n      var c;\n\n      while (!done && (c = lexer._nextCharCode()) >= 0) {\n        switch (true) {\n          case c === 0x3e:\n            // >\n            done = true;\n            break;\n\n          case c >= 0x30 && c <= 0x39: // 0 - 9\n\n          case c >= 0x41 && c <= 0x5a: // A - B\n\n          case c >= 0x61 && c <= 0x7a:\n            // a - b\n            digits.push(String.fromCharCode(c));\n            addCharacter();\n            break;\n\n          case Lexer.isWhiteSpace(c):\n            break;\n\n          default:\n            lexer._warning('invalid character `' + String.fromCharCode(c) + '` in hex string');\n\n            break;\n        }\n      }\n\n      addCharacter(true);\n      return new PDFString(str);\n    }\n  }]);\n\n  return PDFString;\n}();\n\nmodule.exports = PDFString;","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/object/string.js"],"names":["Lexer","require","PDFString","str","hex","i","len","length","h","charCodeAt","toString","slice","replace","xref","lexer","trial","literal","parseLiteral","undefined","parseHex","Error","getString","shift","done","open","c","_nextCharCode","String","fromCharCode","oct","readString","parseInt","digits","addCharacter","force","push","join","isWhiteSpace","_warning","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Lexer = require('../parser/lexer')\n\nclass PDFString {\n  constructor(str) {\n    this.str = str\n  }\n\n  toHexString() {\n    // convert to hex string\n    let hex = ''\n    for (let i = 0, len = this.str.length; i < len; ++i) {\n      let h = (this.str.charCodeAt(i) - 31).toString(16)\n      // left pad zeroes\n      h = ('0000' + h).slice(-4)\n      hex += h\n    }\n    return '<' + hex + '>'\n  }\n\n  toString() {\n    return '(' + this.str.replace(/\\\\/g, '\\\\\\\\')\n                         .replace(/\\(/g, '\\\\(')\n                         .replace(/\\)/g, '\\\\)') + ')'\n  }\n\n  static parse(xref, lexer, trial) {\n    const literal = PDFString.parseLiteral(lexer, trial)\n    const hex = literal === undefined && PDFString.parseHex(lexer, trial)\n\n    if (!literal && !hex) {\n      if (trial) {\n        return undefined\n      }\n\n      throw new Error('Invalid string')\n    }\n\n    return literal || hex\n  }\n\n  static parseLiteral(lexer, trial) {\n    if (lexer.getString(1) !== '(') {\n      if (trial) {\n        return undefined\n      }\n\n      throw new Error('Invalid literal string')\n    }\n\n    lexer.shift(1)\n\n    let str = ''\n\n    let done = false\n    let open = 0\n    let c\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (c) {\n        case 0x28: // (\n          open++\n          str += String.fromCharCode('(')\n          break\n        case 0x29: // )\n          if (open === 0) {\n            done = true\n          } else {\n            open--\n            str += String.fromCharCode(')')\n          }\n          break\n        case 0x5c: // \\\n          c = lexer._nextCharCode()\n          switch (c) {\n            case 0x6e: // \\n\n              str += '\\n'\n              break\n            case 0x72: // \\r\n              str += '\\r'\n              break\n            case 0x74: // \\t\n              str += '\\t'\n              break\n            case 0x62: // \\b\n              str += '\\b'\n              break\n            case 0x66: // \\f\n              str += '\\f'\n              break\n            case 0x28: // '('\n            case 0x29: // ')'\n            case 0x5c: // '\\'\n              str += String.fromCharCode(c)\n              break\n            case 0x30: // 0\n            case 0x31: // 1\n            case 0x32: // 2\n            case 0x33: // 3\n            case 0x34: // 4\n            case 0x35: // 5\n            case 0x36: // 6\n            case 0x37: // 7\n            case 0x38: // 8\n            case 0x39: // 9\n              const oct = String.fromCharCode(c) + lexer.readString(2)\n              str += String.fromCharCode(parseInt(oct, 8))\n              break\n            default:\n              lexer.shift(-1)\n              break\n          }\n          break\n        case 0x0d: // CR\n        case 0x0a: // LF\n          // ignore EOL characters\n          break\n        default:\n          str += String.fromCharCode(c)\n          break\n      }\n    }\n\n    return new PDFString(str)\n  }\n\n  static parseHex(lexer, trial) {\n    if (lexer.getString(1) !== '<') {\n      if (trial) {\n        return undefined\n      }\n\n      throw new Error('Invalid hex string')\n    }\n\n    lexer.shift(1)\n\n    let str = ''\n\n    let done = false\n    const digits = []\n    const addCharacter = function(force) {\n      if (digits.length !== 2) {\n        if (digits.length === 1 && force) {\n          digits.push('0')\n        } else {\n          return\n        }\n      }\n\n      str += String.fromCharCode(parseInt(digits.join(''), 16))\n      digits.length = 0\n    }\n\n    let c\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x3e: // >\n          done = true\n          break\n        case c >= 0x30 && c <= 0x39: // 0 - 9\n        case c >= 0x41 && c <= 0x5a: // A - B\n        case c >= 0x61 && c <= 0x7a: // a - b\n          digits.push(String.fromCharCode(c))\n          addCharacter()\n          break\n        case Lexer.isWhiteSpace(c):\n          break\n        default:\n          lexer._warning('invalid character `' + String.fromCharCode(c) + '` in hex string')\n          break\n      }\n    }\n\n    addCharacter(true)\n\n    return new PDFString(str)\n  }\n}\n\nmodule.exports = PDFString\n"]},"metadata":{},"sourceType":"script"}