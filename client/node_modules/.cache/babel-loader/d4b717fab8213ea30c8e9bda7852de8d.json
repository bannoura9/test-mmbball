{"ast":null,"code":"'use strict'; // Converts a hex color expr. like #123456 into an array [r, g, b],\n// where r, g, b are in the range of 0 and 1\n\nexports.colorToRgb = function (hex) {\n  if (hex === undefined || hex === null) {\n    return;\n  }\n\n  if (typeof hex === 'string') {\n    hex = parseInt(hex.replace('#', ''), 16);\n  }\n\n  var r = (hex >> 16) / 255;\n  var g = (hex >> 8 & 255) / 255;\n  var b = (hex & 255) / 255;\n  return [r, g, b];\n};\n\nexports.rgbEqual = function (lhs, rhs) {\n  return lhs && rhs && lhs[0] === rhs[0] && lhs[1] === rhs[1] && lhs[2] === rhs[2];\n};\n\nexports.toArrayBuffer = function (b) {\n  if (b instanceof ArrayBuffer) {\n    return b;\n  } else {\n    return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);\n  }\n};\n\nexports.defaults = function (val, def) {\n  return val !== undefined ? val : def;\n};\n\nexports.inflate = function (obj) {\n  var filter = obj.properties.get(\"Filter\");\n\n  if (!filter || filter.name !== \"FlateDecode\") {\n    throw new Error(\"Only FlateDecode filter are supported\");\n  }\n\n  var columns = 1;\n  var predictor = 1;\n  var params = obj.properties.get(\"DecodeParms\");\n\n  if (params) {\n    columns = params.get(\"Columns\");\n    predictor = params.get(\"Predictor\");\n  }\n\n  var inflate = require('pako/lib/inflate').inflate;\n\n  var res = inflate(obj.content.content);\n\n  if (predictor === 1) {\n    return res;\n  }\n\n  if (predictor >= 10 && predictor <= 15) {\n    // PNG filter\n    res = pngFilter(res, columns);\n  } else {\n    throw new Error('Unsupported predictor ' + predictor);\n  }\n\n  return res;\n};\n\nfunction pngFilter(src, columns) {\n  var columnCount = columns + 1;\n  var rowCount = src.length / columnCount;\n  var res = new Uint8Array(columns * rowCount);\n\n  for (var y = 0; y < rowCount; ++y) {\n    var filter = src[y * columnCount];\n\n    if (filter === 0) {\n      for (var x = 0; x < columns; ++x) {\n        res[y * columns + x] = src[y * columnCount + 1 + x];\n      }\n    } else if (filter === 2) {\n      for (var _x = 0; _x < columns; _x++) {\n        var prev = y === 0 ? 0 : res[(y - 1) * columns + _x];\n        res[y * columns + _x] = prev + src[y * columnCount + 1 + _x] & 0xff;\n      }\n    } else {\n      throw new Error('Unsupported PNG filter ' + filter);\n    }\n  }\n\n  return res;\n}","map":{"version":3,"sources":["/Users/mikebannoura/Dropbox/My Mac (MacBook-Pro-Mike.local)/Desktop/mmbball-app/client/node_modules/pdfjs/lib/util.js"],"names":["exports","colorToRgb","hex","undefined","parseInt","replace","r","g","b","rgbEqual","lhs","rhs","toArrayBuffer","ArrayBuffer","buffer","slice","byteOffset","byteLength","defaults","val","def","inflate","obj","filter","properties","get","name","Error","columns","predictor","params","require","res","content","pngFilter","src","columnCount","rowCount","length","Uint8Array","y","x","prev"],"mappings":"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","sourcesContent":["'use strict'\n\n// Converts a hex color expr. like #123456 into an array [r, g, b],\n// where r, g, b are in the range of 0 and 1\nexports.colorToRgb = function(hex) {\n  if (hex === undefined || hex === null) {\n    return\n  }\n\n  if (typeof hex === 'string') {\n    hex = parseInt(hex.replace('#', ''), 16)\n  }\n\n  const r = (hex >> 16) / 255\n  const g = ((hex >> 8) & 255) / 255\n  const b = (hex & 255) / 255\n\n  return [r, g, b]\n}\n\nexports.rgbEqual = function(lhs, rhs) {\n  return lhs && rhs && lhs[0] === rhs[0] && lhs[1] === rhs[1] && lhs[2] === rhs[2]\n}\n\nexports.toArrayBuffer = function(b) {\n  if (b instanceof ArrayBuffer) {\n    return b\n  } else {\n    return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength)\n  }\n}\n\nexports.defaults = function(val, def) {\n  return val !== undefined ? val : def\n}\n\n\nexports.inflate = function(obj) {\n  let filter = obj.properties.get(\"Filter\")\n  if (!filter || filter.name !== \"FlateDecode\") {\n    throw new Error(\"Only FlateDecode filter are supported\")\n  }\n\n  let columns = 1\n  let predictor = 1\n  const params = obj.properties.get(\"DecodeParms\")\n  if (params) {\n    columns = params.get(\"Columns\")\n    predictor = params.get(\"Predictor\")\n  }\n\n  const inflate = require('pako/lib/inflate').inflate\n  let res = inflate(obj.content.content)\n\n  if (predictor === 1) {\n    return res\n  }\n\n  if (predictor >= 10 && predictor <= 15) {\n    // PNG filter\n    res = pngFilter(res, columns)\n  } else {\n    throw new Error('Unsupported predictor ' + predictor)\n  }\n\n  return res\n}\n\nfunction pngFilter(src, columns) {\n  const columnCount = columns + 1;\n  const rowCount = src.length / columnCount\n\n  const res = new Uint8Array(columns * rowCount);\n  for (let y = 0; y < rowCount; ++y) {\n    const filter = src[y * columnCount]\n    if (filter === 0) {\n      for (let x = 0; x < columns; ++x) {\n        res[y * columns + x] = src[y * columnCount + 1 + x]\n      }\n    } else if (filter === 2) {\n      for (let x = 0; x < columns; x++) {\n        const prev = (y === 0) ? 0 : res[(y - 1) * columns + x]\n        res[y * columns + x] = (prev + src[y * columnCount + 1 + x]) & 0xff\n      }\n    } else {\n      throw new Error('Unsupported PNG filter ' + filter)\n    }\n  }\n  return res\n}\n\n"]},"metadata":{},"sourceType":"script"}